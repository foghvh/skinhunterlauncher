/// src Start of App.jsx ///
import { Route, Routes,  HashRouter } from "react-router-dom";
import React, { useEffect} from "react";
// import Home from "./pages/home.jsx";
// import Landing from "./pages/landing.jsx";
// import LandingPage from "./pages/landingv0.jsx";
import { _ready } from "./data/data";
import { usePromise } from "./data/hooks";
import { Champion } from "./pages/champions.jsx";
import ScrollToTop from "./components/ScrollTop.jsx";
import "./styles.css";
import { Theme, Spinner } from "@radix-ui/themes";
import { UserProvider } from "./context/usercontext.jsx";
import { Toaster } from "sonner";
import AppInterface from "./pages/appinterface.jsx";
function App() {
  const ready = usePromise(_ready);
  useEffect(() => {
  }, []);
  return (
    <>


        <HashRouter>
          <ScrollToTop />
          <UserProvider>
          <Toaster expand={true} position="top-right" theme="dark" toastOptions={{
                  style: {
                    background: '#1a1a1a',
                    padding: '15px',
                    border: "0.5px",
                    borderStyle: "solid",
                    borderColor: "#1e1e1e"
                  }
                }} />
          <Theme accentColor='iris' appearance='dark' >


            {ready ? (
              <>

                <Routes>

                  <Route path="/" element={<AppInterface />} />
                  <Route path="/home" element={<AppInterface />} />
                  {/* <Route path="/landing" element={<Home />} /> */}

                  <Route path="/champions/:champion" element={<Champion />} />

                </Routes>

              </>

            ) : (

              <div className="h-screen w-screen grid place-items-center">
                <div>
                  <Spinner size="3" ></Spinner>
                </div>
              </div>
            )}
                      </Theme>

          </UserProvider>
        </HashRouter>
    </>
  );

}

export default App;

/// src End of App.jsx ///

/// src Start of index.jsx ///
import {StrictMode} from 'react';
import {createRoot} from 'react-dom/client';
import React from 'react';
import App from './App.jsx'
import "./styles.css";
import { Theme } from "@radix-ui/themes";
// This is the ID of the div in your index.html file

const rootElement = document.getElementById('root');
const root = createRoot(rootElement);



root.render(
  <StrictMode>
    
      <App />
  </StrictMode>
  );
/// src End of index.jsx ///

/// src Start of styles.css ///
@import url("https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap");

@import "tailwindcss/base";
@import "@radix-ui/themes/styles.css";

@tailwind components;
@tailwind utilities;

.radix-themes {
  --color-background: #000000;
  /* Fondo de la página */
  --color-panel-solid: #121212;
  /* Fondo de paneles sólidos como tarjetas */
  --color-panel-translucent: rgba(0, 0, 0, 0.5);
  /* Fondo de paneles translúcidos */
  --color-surface: #1a1a1a;
  /* Fondo de inputs, checkboxes, etc. */
  --color-overlay: rgba(0, 0, 0, 0.8);
  /* Fondo de overlays de diálogos */
  --data-state-closed: animation: none !important;

}
.rt-BaseDialogScroll {

overflow: hidden;


}
/* div.radix-themes.dark.rt-BaseDialogOverlay.rt-DialogOverlay {
  animation: none !important;
}

div.radix-themes.dark.rt-BaseDialogOverlay.rt-DialogOverlay::before {
  animation: none !important;
}

div#radix-\\:r2\\:rt-BaseDialogContent.rt-DialogContent.rt-r-size-3.rt-r-max-w.custom-dialog {
  animation: none !important;
} */


.rt-BaseDialogContent:where([data-state='open']) {
  animation: rt-dialog-content-show 150ms cubic-bezier(0.16, 1, 0.3, 1) !important;
}
@media (prefers-reduced-motion: no-preference) {


  .rt-BaseDialogContent:where([data-state='open']) {
    animation-name: rt-dialog-content-show !important;
    animation-duration: 150ms !important;
    animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1) !important;
    animation-fill-mode: forwards !important;
  }
  
  


}
.rt-BaseDialogContent:where([data-state='open']) {
  animation-name: rt-dialog-content-show !important;
  animation-duration: 150ms !important;
  animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1) !important;
  animation-fill-mode: forwards !important;
}

.rt-dialog-content-hide {

  animation: none !important;


}

.rt-dialog-overlay-no-op {

  animation: none !important;
}

.rt-fade-out {


  animation: none !important;

}

.rt-BaseDialogContent:where([data-state='close']) {
  animation: none !important;
  ;

}

.rt-BaseDialogContent:where([data-state='close']) {

  animation: none !important;
  ;

}

.rt-BaseDialogContent:where([data-state='close'])::before {
  animation: none !important;
  ;

}

.rt-BaseDialogOverlay:where([data-state='close']) {
  animation: none !important;
  ;

}

.rt-BaseDialogOverlay:where([data-state='open'])::before {
  animation: none !important;
  ;

}

.radix-themes [rt-BaseDialogOverlay][data-state="closed"],
[rt-DialogOverlay][data-state="closed"] {
  animation: none !important;
}

[radix-themes][dark][rt-BaseDialogOverlay][data-state="closed"] {

  animation: none !important;


}

[radix-themes][dark][rt-DialogOverlay][data-state="closed"] {
  animation: none !important;
}

body {
  margin: 0;
  font-family: "Poppins", "Roboto", "Helvetica Neue", sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background: linear-gradient(to top, #050505, #111);
  background-attachment: fixed;
  overflow-y: scroll;
  color: white;
  overflow-x: hidden;
  /* cursor: url(https://cur.cursors-4u.net/games/gam-14/gam1340.cur), auto !important; */

}

body::-webkit-scrollbar {
  display: none;
  /* Chrome, Safari y Edge */
}
/// src End of styles.css ///

/// components Start of ChampionDialog.jsx ///
import React, { memo, useState } from 'react';
import {
  Text,
  Card,
  Box,
  Flex,
  Skeleton,
  Inset,
  Separator,
  Dialog,
  Button,
  Progress,
  Popover,
  IconButton,
  Slider,
  Badge,
  ScrollArea
} from '@radix-ui/themes';
import { InfoCircledIcon } from '@radix-ui/react-icons';

const ChampionDialog = memo(({ champData, style, roleColors, damageColors, asset }) => {
  const [isLoadingDs, setIsLoadingDs] = useState(true);

  const handleImageLoads = () => setIsLoadingDs(false);

  return (
    <Dialog.Root>
      <Dialog.Trigger asChild>
        <Button mt="5">View more</Button>
      </Dialog.Trigger>
      <Dialog.Content className="custom-dialog" maxWidth="850px" aria-describedby={undefined}>
        <Dialog.Title>{champData.name}</Dialog.Title>

        <Flex
          direction={{ initial: "column", md: "row", xl: "row" }}
          justify={{ initial: "center", md: "space-between", xl: "space-between" }}
          align={{ initial: "center", md: "start", xl: "start-between" }}
          gap="4"
          style={{ width: "100%" }}
          className="w-full"
        >
          {/* Champion Image and Bio */}
          <Box style={{ flex: 1, maxWidth: "100%" }}>
            <Card
              size="4"
              style={{
                width: "100%",
                maxWidth: "450px",
                padding: "1rem",
              }}
            >
              {isLoadingDs && (
                <Box
                  className="skeleton-container bg-primary"
                  style={{
                    width: "100%",
                    aspectRatio: "16/9",
                    height: "100%",
                    maxHeight: "300px",
                  }}
                >
                  <Skeleton className="w-full h-full" />
                </Box>
              )}
                        {/* Champion Image & Bio */}

              <Inset clip="border-box" side="all" pb="current" size="" style={{ display: isLoadingDs ? "none" : "block" }}>
                <img
                  src={
                    champData?.defaultSkins[0]?.splashPath
                      ? asset(champData.defaultSkins[0].splashPath)
                      : ""
                  }
                  alt="Champion Splash"
                  style={{
                    display: "block",
                    objectFit: "cover",
                    width: "100%",
                    height: "auto",
                    maxHeight: "300px",
                  }}
                  onLoad={handleImageLoads}
                />
              </Inset>
              <ScrollArea type="auto" scrollbars="vertical" style={{ height: 180 }}>
              <Text as="p" size="3" className='pr-4 pt-2' >
                {champData.shortBio}
              </Text>
              </ScrollArea>
            </Card>
          </Box>

          {/* Champion Stats */}
          <Flex direction="column" gap="3" align="start" className="w-full" style={{ flex: 1 }}>
            {/* Difficulty */}
            <Flex direction="column" style={{ width: "100%" }}>
              <Text as="h1" size="5" mb="4">Difficulty
                <Popover.Root>
                  <Popover.Trigger>
                    <IconButton variant="soft" ml="2" size="1">
                      <InfoCircledIcon />
                    </IconButton>
                  </Popover.Trigger>
                  <Popover.Content size="3" maxWidth="300px">
                    <Text as="p" trim="both" size="3">
                      The champion difficulty.
                    </Text>
                  </Popover.Content>
                </Popover.Root>
              </Text>
              <Separator size="4" orientation="horizontal" />
              <Box align="center">
                <Progress value={champData?.tacticalInfo?.difficulty * 25 || 0} size="2" mx="auto" />
              </Box>
            </Flex>

            {/* Style */}
            <Flex direction="column" style={{ width: "100%" }}>
              <Text as="h1" size="5">Style
                <Popover.Root>
                  <Popover.Trigger>
                    <IconButton ml="2" variant="soft" size="1">
                      <InfoCircledIcon />
                    </IconButton>
                  </Popover.Trigger>
                  <Popover.Content size="3" maxWidth="300px">
                    <Text as="p" trim="both" size="3">
                      The champion's tendency to deal damage using basic attacks vs. abilities.
                    </Text>
                  </Popover.Content>
                </Popover.Root>
              </Text>
              <Separator size="4" orientation="horizontal" />
              <Flex direction="row" justify="between" align="center" my="auto" style={{ marginTop: "1.5rem", height: "100%" }}>
                <Box
                  style={{
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    opacity: champData?.tacticalInfo?.style <= 5 ? 1 : 0.5,
                    transition: "opacity 0.3s",
                  }}
                >
                  <img
                    src={style({ tipo: "kASHighlight" })?.[0] || ""}
                    alt={style({ tipo: "kASHighlight" })?.[1] || "Attack"}
                    style={{ height: "40px", width: "40px" }}
                  />
                </Box>
                <Box style={{ flexGrow: 1, margin: "0 1rem" }}>
                  <Slider
                    defaultValue={[champData?.tacticalInfo?.style * 10 || 0]}
                    size="2"
                    style={{ width: "100%", backgroundColor: "#6e6e6e", pointerEvents: "none" }}
                  />
                </Box>
                <Box
                  style={{
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    opacity: champData?.tacticalInfo?.style > 5 ? 1 : 0.5,
                    transition: "opacity 0.3s",
                  }}
                >
                  <img
                    src={style({ tipo: "kMagicHighlight" })?.[0] || ""}
                    alt={style({ tipo: "kMagicHighlight" })?.[1] || "Magic"}
                    style={{ height: "40px", width: "40px" }}
                  />
                </Box>
              </Flex>
            </Flex>

            {/* Damage */}
            <Flex direction="column" style={{ width: "100%" }}>
              <Text as="h1" size="5">Damage
                <Popover.Root>
                  <Popover.Trigger>
                    <IconButton variant="soft" ml="2" size="1">
                      <InfoCircledIcon />
                    </IconButton>
                  </Popover.Trigger>
                  <Popover.Content size="3" maxWidth="300px">
                    <Text as="p" trim="both" size="3">
                      The champion tendency to deal physical, magic or mixed damage.
                    </Text>
                  </Popover.Content>
                </Popover.Root>
              </Text>
              <Separator size="4" orientation="horizontal" />
              <Flex direction="row" gap="10px" wrap="wrap">
                <Badge
                  mt="3"
                  variant="soft"
                  color={damageColors[champData.tacticalInfo.damageType] || "gray"}
                  style={{ textTransform: "capitalize", fontSize: "0.9rem" }}
                >
                  {champData.tacticalInfo.damageType.slice(1)}
                </Badge>
                <Box className="w-full" mt="2" align="center">
                  <Progress value={champData?.playstyleInfo?.damage * 25 || 0} size="2" mx="auto" />
                </Box>
              </Flex>
            </Flex>

            {/* Roles */}
            <Flex direction="column" style={{ width: "100%", marginTop: "1rem" }}>
              <Text as="h1" size="5">Roles
                <Popover.Root>
                  <Popover.Trigger>
                    <IconButton variant="soft" ml="2" size="1">
                      <InfoCircledIcon />
                    </IconButton>
                  </Popover.Trigger>
                  <Popover.Content size="3" maxWidth="300px">
                    <Text as="p" trim="both" size="3">
                    Champion Roles
                    </Text>
                  </Popover.Content>
                </Popover.Root>
              </Text>
              <Separator size="4" orientation="horizontal" />
              <Flex direction="row" gap="10px" wrap="wrap">
                {champData.roles.map((role, index) => (
                  <Badge
                    key={index}
                    mt="3"
                    variant="soft"
                    color={roleColors[role] || "gray"}
                    style={{ textTransform: "capitalize", fontSize: "0.9rem" }}
                  >
                    {role}
                  </Badge>
                ))}
              </Flex>
            </Flex>

            <Dialog.Description />
            <Dialog.Close className="custom-dialog" asChild>
              <Button>Close</Button>
            </Dialog.Close>
          </Flex>
        </Flex>
      </Dialog.Content>
    </Dialog.Root>
  );
});

export default ChampionDialog;

/// components End of ChampionDialog.jsx ///

/// components Start of Console.jsx ///
import React, { useEffect, useRef } from 'react';
import { useModLogs } from '../data/hooks';
import { ScrollArea } from '@radix-ui/themes';

const Console = () => {
  const { logs } = useModLogs();
  const scrollRef = useRef(null);

  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [logs]);

  return (
    <ScrollArea 
      ref={scrollRef}
      className="h-[200px] bg-[#0f1729]/80 backdrop-blur-sm border border-[#586a9e] rounded-lg p-2 font-mono text-sm"
      scrollbars="vertical"
    >
      {logs.map((log) => (
        <div
          key={log.id}
          className={`mb-1 ${
            log.type === 'stderr' ? 'text-red-400' : 'text-green-400'
          }`}
        >
          <span className="text-gray-500">[{log.timestamp}]</span>{' '}
          <span>{log.message}</span>
        </div>
      ))}
    </ScrollArea>
  );
};

export default Console;

/// components End of Console.jsx ///

/// components Start of ContainerForm.jsx ///
import React, { useState } from "react";
import { useNavigate } from "react-router";
import { Button, Text, Flex, Card } from "@radix-ui/themes";
import { PersonIcon, LockClosedIcon, EnvelopeClosedIcon, Cross1Icon } from "@radix-ui/react-icons";
import { toast } from "sonner";
import { Login, Register } from '../../wailsjs/go/main/App';

const ContainerForm = ({ closePopup, setCurrentPopup, currentPopup }) => {
    const [formData, setFormData] = useState({ login: "", password: "", email: "" });
    const [statusMessage, setStatusMessage] = useState("");
    const navigate = useNavigate();

    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData({ ...formData, [name]: value });
    };

    const handleRegister = async (e) => {
        e.preventDefault();
        try {
            const response = await Register(formData.email, formData.password, formData.login);
            if (response.success) {
                toast.success(response.message);
                setCurrentPopup("login");
            } else {
                toast.error(response.error || "Registration failed");
            }
            setStatusMessage(response.message);
        } catch (error) {
            console.error(error);
            toast.error("Registration failed: " + (error.message || "Unknown error"));
        }
    };

    const handleLogin = async (e) => {
        e.preventDefault();
        try {
            const response = await Login(formData.login, formData.password);
            if (response.success) {
                localStorage.setItem("token", response.token);
                toast.success(`Welcome back! ${response.user.login}`);
                navigate("/home");
                closePopup();
            } else {
                toast.error(response.error || "Login failed");
                setStatusMessage("Unable to log in. Please check your credentials.");
            }
        } catch (error) {
            console.error("Login error:", error);
            toast.error("Login failed: " + (error.message || "Unknown error"));
            setStatusMessage("Unable to log in. Please check your credentials.");
        }
    };
    return (
        <Card variant="ghost" style={{ padding: '24px' }}>
            <Flex justify="between" align="center">
                <Text size="5" weight="bold">{currentPopup === "register" ? "Register" : "Login"}</Text>
                <Button variant="ghost" onClick={closePopup}>
                    <Cross1Icon width="20" height="20" />
                </Button>
            </Flex>

            {currentPopup === "register" ? (
                <form onSubmit={handleRegister} style={{ marginTop: '16px' }}>
                    <Flex direction="column" gap="3">
                        <Flex align="center" gap="2">
                            <PersonIcon width="18" height="18" />
                            <Text>Login</Text>
                        </Flex>
                        <input name="login"
                            value={formData.login}
                            onChange={handleChange}
                            placeholder="Enter your login"
                            required
                            style={{ flex: 1, padding: "10px", background: 'transparent', border: 'none', color: 'white', outline: 'none', backgroundColor: 'var(--color-surface)', padding: "5px" }}>

                        </input>

                        <Flex align="center" gap="2">
                            <LockClosedIcon width="18" height="18" />
                            <Text>Password</Text>
                        </Flex>
                        <input type="password"
                            name="password"
                            value={formData.password}
                            onChange={handleChange}
                            placeholder="Enter your password"
                            required
                            style={{ flex: 1, background: 'transparent', border: 'none', color: 'white', outline: 'none', backgroundColor: 'var(--color-surface)', padding: "5px" }}>

                        </input>

                        <Flex align="center" gap="2">
                            <EnvelopeClosedIcon width="18" height="18" />
                            <Text>Email</Text>
                        </Flex>
                        <input type="email"
                            name="email"
                            value={formData.email}
                            onChange={handleChange}
                            placeholder="Enter your email"
                            required
                            style={{ flex: 1, background: 'transparent', border: 'none', color: 'white', outline: 'none', backgroundColor: 'var(--color-surface)', padding: "5px" }}>

                        </input>

                        <Text color="gray">{statusMessage}</Text>
                        <Text size="2">
                            Already have an account?{' '}
                            <Text as="span" color="blue" style={{ cursor: 'pointer', textDecoration: 'underline' }} onClick={() => setCurrentPopup("login")}>
                                Login
                            </Text>
                        </Text>
                        <Button type="submit">REGISTER</Button>
                    </Flex>
                </form>
            ) : (
                <form onSubmit={handleLogin} style={{ marginTop: '16px' }}>
                    <Flex direction="column" gap="3">
                        <Flex align="center" gap="2">
                            <PersonIcon width="18" height="18" />
                            <Text>Login</Text>
                        </Flex>
                        <input name="login"
                            value={formData.login}
                            onChange={handleChange}
                            placeholder="Enter your login"
                            required
                            style={{ flex: 1, background: 'transparent', border: 'none', color: 'white', outline: 'none', backgroundColor: 'var(--color-surface)', padding: "5px" }}>

                        </input>

                        <Flex align="center" gap="2">
                            <LockClosedIcon width="18" height="18" />
                            <Text>Password</Text>
                        </Flex>
                        <input type="password"
                            name="password"
                            value={formData.password}
                            onChange={handleChange}
                            placeholder="Enter your password"
                            required
                            style={{ flex: 1, background: 'transparent', border: 'none', color: 'white', outline: 'none', backgroundColor: 'var(--color-surface)', padding: "5px" }}>

                        </input>

                        <Text color="gray">{statusMessage}</Text>
                        <Text size="2">
                            Don't have an account?{' '}
                            <Text as="span" color="blue" style={{ cursor: 'pointer', textDecoration: 'underline' }} onClick={() => setCurrentPopup("register")}>
                                Register
                            </Text>
                        </Text>
                        <Button  type="submit">LOGIN</Button>
                    </Flex>
                </form>
            )}
        </Card>
    );
};

export default ContainerForm;
/// components End of ContainerForm.jsx ///

/// components Start of InstalledSkin.jsx ///
// @InstalledSkin.jsx (Corrected and Robust)

import React from 'react';
import {
  Button,
  Text,
  ScrollArea,
  Flex,
  Box,
  Avatar,
  Checkbox
} from '@radix-ui/themes';
import { toast } from 'sonner';
import { motion, AnimatePresence } from "framer-motion";
import { champions, asset, rarity, checkLegacy, getChromasForSkin, _champData, _champDataName, splitId } from "../data/data";
import { GetInstalledSkins, UninstallMultipleSkins } from '../../wailsjs/go/main/App';

const InstalledSkinsDialog = ({ isOpen, onOpenChange }) => {
  const [installedSkins, setInstalledSkins] = React.useState([]);
  const [selectedSkins, setSelectedSkins] = React.useState([]);
  const [isLoading, setIsLoading] = React.useState(true);

  const loadInstalledSkins = async () => {
    setIsLoading(true);
    try {
      const installedSkinsData = await GetInstalledSkins();
      console.log("installedSkinsData:", installedSkinsData); // Depuración

      if (!Array.isArray(installedSkinsData)) {
        throw new Error("GetInstalledSkins did not return an array");
      }

      const enhancedSkins = installedSkinsData.map(skinInfo => {
        const champion = champions.find(c => String(c.id) === String(skinInfo.championId));

        const skinName = skinInfo.skinName || 'Unknown Skin';
        const chromaName = skinInfo.chromaName !== "null" ? skinInfo.chromaName : null; // Manejo de "null" como string
        const tilePath = skinInfo.imageUrl;

        let displayName = skinName;
        if (chromaName) {
          displayName = `${skinName} (${chromaName})`;
        }

        return {
          championId: parseInt(skinInfo.championId),
          skinInfo,
          champion,
          skin: {
            id: skinInfo.skinId,
            name: displayName,
            chromaName,
            tilePath
          }
        };
      });

      setInstalledSkins(enhancedSkins);

    } catch (error) {
      console.error("Error loading skins:", error);
    } finally {
      setIsLoading(false);
    }
  };


  React.useEffect(() => {
    loadInstalledSkins();
  }, []);

  const handleUninstallSelected = async () => {
    if (selectedSkins.length === 0) return;

    const loadingToast = toast.loading(`Uninstalling ${selectedSkins.length} skin(s)...`);
    try {
      const result = await UninstallMultipleSkins(selectedSkins);
      if (!result.success) {
        throw new Error(result.error || 'Failed to uninstall selected skins');
      }
      await loadInstalledSkins();
      toast.dismiss(loadingToast);
      toast.success(`${selectedSkins.length} skin(s) uninstalled successfully`);
    } catch (error) {
      toast.dismiss(loadingToast);
      toast.error(error.message || 'Failed to uninstall selected skins');
    }
  };

  const toggleSkinSelection = (championId) => {
    setSelectedSkins(prev => {
      if (prev.includes(championId)) {
        return prev.filter(id => id !== championId);
      } else {
        return [...prev, championId];
      }
    });
  };

  const toggleSelectAll = () => {
    if (selectedSkins.length === installedSkins.length) {
      setSelectedSkins([]);
    } else {
      setSelectedSkins(installedSkins.map(skin => skin.championId));
    }
  };


  return (
    <Flex direction="column" gap="3">
      {!isLoading && installedSkins.length > 0 && (
        <Flex justify="between" align="center" className="px-2">
          <Checkbox
            checked={selectedSkins.length === installedSkins.length && installedSkins.length > 0}
            onCheckedChange={toggleSelectAll}
          >
            <Text as='h1' size="3" className="text-gray-200">Select All</Text>
          </Checkbox>
          <Button
            color="red"
            disabled={selectedSkins.length === 0}
            onClick={handleUninstallSelected}
            size="2"
          >
            Uninstall Selected ({selectedSkins.length})
          </Button>
        </Flex>
      )}

      <ScrollArea style={{ height: 330 }} scrollbars="vertical">
        <div>
          {isLoading ? (
            <Text className="text-gray-200">Loading installed skins...</Text>
          ) : installedSkins.length === 0 ? (
            <div style={{
              position: 'relative',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              height: '100%',
              flexDirection: 'column'
            }}>
              <img
                src="https://raw.communitydragon.org/latest/plugins/rcp-fe-lol-static-assets/global/default/images/icon-shocked-poro.png"
                alt="Shocked Poro"
                style={{
                  filter: 'grayscale(1) saturate(1)',
                  width: '160px',
                  height: 'auto',
                  marginTop: '1em',
                  marginBottom: '1em'
                }}
              />
              <Text className="text-gray-600">No skins installed</Text>
            </div>
          ) : (
            <AnimatePresence>
              {installedSkins.map(({ championId, skinInfo, champion, skin }, i) => {

                return (
                  <motion.div
                    key={championId}
                    initial={{ opacity: 0, x: -20 }}
                    animate={{ opacity: 1, x: 0 }}
                    transition={{ delay: i * 0.05 }}
                  >
                    <Flex
                      align="center"
                      className={`p-2 transition-colors duration-150 ${selectedSkins.includes(championId) ? 'bg-[#2a2a2a]' : 'hover:bg-[#222222]'
                        }`}
                      onClick={() => toggleSkinSelection(championId)}
                    >
                      <Checkbox
                        checked={selectedSkins.includes(championId)}
                        className="mr-2"
                        onCheckedChange={() => toggleSkinSelection(championId)}
                      />
                      <Box className="relative mr-4">
                        <Avatar
                          size="3"
                          src={asset(skin.tilePath)}
                          fallback={(champion?.name || skin.name || '?').charAt(0)} // Use skin.name for fallback
                          className="w-[48px] h-[48px]"
                        />
                      </Box>
                      <Flex direction="column" gap="1" className="flex-1">
                        <Flex align="center" gap="2">
                          <Text className="text-gray-200 font-medium">
                            {skin.name}

                          </Text>
                          {/* Conditionally render additional info based on availability */}
                          {skin && (
                            <RenderSkinProperties skin={skin} championId={championId} />
                          )}
                        </Flex>
                        <Text className="text-[#bebebe] text-sm">
                          {champion?.name || `Champion ID: ${championId}`}
                        </Text>
                      </Flex>
                    </Flex>
                  </motion.div>
                )
              })}
            </AnimatePresence>
          )}
        </div>
      </ScrollArea>
    </Flex>
  );
};

//Nuevo componente funcional RenderSkinProperties
const RenderSkinProperties = ({ skin, championId }) => {
  const [skinProperties, setSkinProperties] = React.useState({
    rarity: null,
    isLegacy: false,
    chromas: null,
  });

  React.useEffect(() => {
    const fetchProperties = async () => {
      const champData = await _champData(championId);
      if (!champData || !champData.skins) {
        return;
      }

      let skinData = champData.skins.find((s) => String(s.id) === String(skin.id));
      if (!skinData && skin.chromaName) {
        skinData = champData.skins.find((s) =>
          s.chromas?.some((c) => c.name === skin.chromaName)
        );
      }

      setSkinProperties({
        rarity: skinData ? skinData.rarity : null,
        isLegacy: skinData ? skinData.isLegacy : false,
        chromas: skinData ? skinData.chromas : null,
      });
    };

    fetchProperties();
  }, [skin, championId]);

  return (
    <>
      {skinProperties.rarity && rarity({ rarity: skinProperties.rarity }) && (
        <img
          width="16"
          height="16"
          src={rarity({ rarity: skinProperties.rarity })?.[0] || ""}
          title={rarity({ rarity: skinProperties.rarity })?.[1] || ""}
          alt={rarity({ rarity: skinProperties.rarity })?.[1] || ""}
        />
      )}
      {skinProperties.isLegacy && (
        <img
          width="16"
          height="16"
          src={checkLegacy({ isLegacy: skinProperties.isLegacy })[0]}
          title={checkLegacy({ isLegacy: skinProperties.isLegacy })[1]}
          alt="Legacy Icon"
        />
      )}
      {skinProperties.chromas && (
        <img
          width="16"
          height="16"
          src="https://raw.communitydragon.org/latest/plugins/rcp-fe-lol-static-assets/global/default/images/skin-viewer/icon-chroma-default.png"
          title={`This skin has ${skinProperties.chromas.length} Chroma(s)`}
          alt="Chromas Icon"
          style={{ borderRadius: '50%' }}
        />
      )}
    </>
  );
};

export default InstalledSkinsDialog;
/// components End of InstalledSkin.jsx ///

/// components Start of ModOverlayButton.jsx ///
import React, { useEffect } from 'react';
import { Button, Flex, Tooltip } from '@radix-ui/themes';
import { PlayIcon, PauseIcon, UpdateIcon } from '@radix-ui/react-icons';
import { toast } from 'sonner';
import useModStatus from '../data/hooks';
import { KillModTools, CheckModToolsRunning } from "../../wailsjs/go/main/App";

const ModOverlayButton = () => {
  const { status, isDisabled, toggleOverlay, logs, waitingForExit, setStatus } = useModStatus();

  // Periodically check if process is still running
  useEffect(() => {
    if (status === "running") {
      const checkInterval = setInterval(() => {
        CheckModToolsRunning()
          .then(isRunning => {
            if (!isRunning && status === "running") {
              // Process died unexpectedly
              setStatus("stopped");
              toast.error("Mod overlay process stopped unexpectedly");
              
              // Update global status
              if (window.updateGlobalStatus) {
                window.updateGlobalStatus("Process stopped unexpectedly");
              }
            }
          })
          .catch(console.error);
      }, 5000); // Check every 5 seconds
      
      return () => clearInterval(checkInterval);
    }
  }, [status, setStatus]);

  const handleToggleOverlay = async () => {
    try {
      if (status === "running") {
        // Use KillModTools directly for more reliable stopping
        const result = await KillModTools();
        if (result) {
          toast.success("Mod overlay stopped successfully");
        } else {
          toast.error("Failed to stop mod overlay");
        }
      } else {
        await toggleOverlay();
        toast.success("Mod overlay started successfully");
      }
    } catch (error) {
      toast.error(error.message || "Failed to toggle overlay");
    }
  };

  const getButtonContent = () => {
    if (waitingForExit) {
      return (
        <Flex align="center" gap="2">
          <UpdateIcon className="animate-spin" />
          Waiting...
        </Flex>
      );
    }
    
    switch (status) {
      case "running":
        return (
          <Flex align="center" gap="2">
            <PauseIcon />
            Stop
          </Flex>
        );
      case "stopped":
      case "idle":
        return (
          <Flex align="center" gap="2">
            <PlayIcon />
            Start
          </Flex>
        );
      case "exiting":
        return (
          <Flex align="center" gap="2">
            <UpdateIcon className="animate-spin" />
            Stopping...
          </Flex>
        );
      case "error":
        return (
          <Flex align="center" gap="2" className="text-red-500">
            <PlayIcon />
            Restart
          </Flex>
        );
      default:
        return (
          <Flex align="center" gap="2">
            <PlayIcon />
            Toggle
          </Flex>
        );
    }
  };

  const getButtonColor = () => {
    if (waitingForExit) return "yellow";
    
    switch (status) {
      case "error":
        return "red";
      case "running":
        return "green";
      case "exiting":
        return "yellow";
      default:
        return "gray";
    }
  };

  const getTooltipContent = () => {
    if (waitingForExit) return "Waiting for exit...";
    if (isDisabled) return "Please wait...";
    
    switch (status) {
      case "running":
        return "Click to stop the mod overlay";
      case "stopped":
      case "idle":
        return "Click to start the mod overlay";
      case "exiting":
        return "Overlay is shutting down...";
      case "error":
        return "An error occurred. Click to restart";
      default:
        return "Toggle mod overlay";
    }
  };

  const getLatestLogs = () => {
    if (!logs || logs.length === 0) return "No recent logs";
    return logs.slice(-3).map(log => `${log.timestamp}: ${log.message}`).join('\n');
  };

  return (
    <Tooltip content={
      <div>
        <div>{getTooltipContent()}</div>
        {logs.length > 0 && (
          <div className="mt-2 text-xs opacity-75">
            Recent logs:
            <pre className="mt-1">{getLatestLogs()}</pre>
          </div>
        )}
      </div>
    }>
      <Button
        onClick={handleToggleOverlay}
        disabled={isDisabled || waitingForExit}
        color={getButtonColor()}
        className="w-fit mt-20"
        size="2"
      >
        {getButtonContent()}
      </Button>
    </Tooltip>
  );
};

export default ModOverlayButton;
/// components End of ModOverlayButton.jsx ///

/// components Start of Omnisearch.jsx ///
import React, { useEffect, useMemo, useState } from "react";
import Fuse from "fuse.js";
import {
  _ready,
  champions,
  skinlines,
  skins,
  asset,
  splitId,
  _champData,
  _champDataName,
  getChromasForSkin,
  rarity
} from "../data/data";
import {
  Dialog,
  TextField,
  Flex,
  Box,
  CheckboxGroup,
  IconButton,
  Text,
  DropdownMenu,
  Avatar,
  ScrollArea,
  Spinner
} from "@radix-ui/themes";
import { MagnifyingGlassIcon, Cross2Icon, DotsHorizontalIcon } from "@radix-ui/react-icons";
import { useNavigate, generatePath } from "react-router";
import { motion, AnimatePresence } from "framer-motion";
import SkinDial from "./SkinDial";

let fuse;

_ready.then(() => {
  fuse = new Fuse([], {
    keys: ["name"],
    threshold: 0.3,
    minMatchCharLength: 2
  });
});

const ResultsSection = ({ title, items, onSelect, selected }) => {
  if (!items.length) return null;

  return (
    <motion.div
      initial={{ opacity: 0, y: -10 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -10 }}
    >
      <Text className="text-gray-400 text-sm px-2 py-1">{title}</Text>
      {items.map((item, i) => (
        <motion.div
          key={item.name}
          initial={{ opacity: 0, x: -20 }}
          animate={{ opacity: 1, x: 0 }}
          transition={{ delay: i * 0.05 }}
          onClick={() => onSelect(item.$$type, item)}
        >
          <Flex
            align="center"
            className={`p-2 hover:bg-[#2a2a2a] transition-colors duration-150 cursor-pointer mr-4
              ${selected === i ? 'bg-[#2a2a2a]' : ''}`}
          >
            <Avatar
              size="3"
              src={item.$$type !== 'skinline' ? asset(item.$$type === 'champion' ? item.squarePortraitPath : item.tilePath) : undefined}
              fallback={item.name.charAt(0).toUpperCase()}
              className="mr-4"
            />
            <Flex direction="column" gap="1">
              <Text className="text-gray-200 font-medium">{item.name}</Text>
              <Text className="text-[#bebebe] text-sm">
                {item.$$type === "champion" ? "Champion" :
                  item.$$type === "skin" ? "Champion Skin" :
                    "Skinline"}
              </Text>
            </Flex>
          </Flex>
        </motion.div>
      ))}
    </motion.div>
  );
};

export function Omnisearch({ 
  isOpen, 
  onOpenChange, 
  setActiveTab, 
  setSelectedChampion, 
  setSelectedSkinLine 
}) {
  const navigate = useNavigate();
  const [query, setQuery] = useState("");
  const [selected, setSelected] = useState(0);
  const [isSkinDialogOpen, setIsSkinDialogOpen] = useState(false);
  const [selectedValues, setSelectedValues] = useState(["1","2", "3"]);
  const [selectedSkinData, setSelectedSkinData] = useState(null);
  const [championData, setChampionData] = useState(null);
  const [champChromas, setChampChromas] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [searchResults, setSearchResults] = useState({ champions: [], skins: [], skinlines: [] });

  // Get the current tab state from the URL or context
  useEffect(() => {
    const path = window.location.pathname;
    if (path.includes('champions')) {
      setActiveTab('champions');
    } else if (path.includes('skinlines')) {
      setActiveTab('skinlines');
    }
  }, []);

  const filteredData = useMemo(() => {
    const data = [];

    if (selectedValues.includes("3")) {
      data.push(...champions.map(c => ({ ...c, $$type: "champion" })));
    }
    if (selectedValues.includes("2")) {
      data.push(...Object.values(skins)
        .filter(skin => !skin.isBase)
        .map(s => ({ ...s, $$type: "skin" })));
    }
    if (selectedValues.includes("1")) {
      data.push(...skinlines.map(sl => ({ ...sl, $$type: "skinline" })));
    }

    return data;
  }, [selectedValues]);

  useEffect(() => {
    fuse = new Fuse(filteredData, {
      keys: ["name"],
      threshold: 0.3,
      minMatchCharLength: 2
    });

    if (query.trim()) {
      performSearch(query);
    } else {
      setSearchResults({ champions: [], skins: [], skinlines: [] });
    }
  }, [filteredData]);

  const performSearch = (searchQuery) => {
    if (!searchQuery.trim()) {
      setSearchResults({ champions: [], skins: [], skinlines: [] });
      return;
    }

    const results = fuse.search(searchQuery, { limit: 25 });
    setSearchResults({
      champions: results.filter(r => r.item.$$type === "champion"),
      skins: results.filter(r => r.item.$$type === "skin"),
      skinlines: results.filter(r => r.item.$$type === "skinline")
    });
  };

  const handleSearchInput = (e) => {
    const newQuery = e.target.value;
    setQuery(newQuery);
    performSearch(newQuery);
  };

  const handleFilterChange = (newValues) => {
    setSelectedValues(newValues);
  };

  useEffect(() => {
    if (!isSkinDialogOpen) {
      setSelectedSkinData(null);
      setChampionData(null);
      setChampChromas([]);
      setIsLoading(false);
    }
  }, [isSkinDialogOpen]);

  const fetchChampionData = async (champId) => {
    try {
      const champData = await _champData(champId);
      if (champData) {
        setChampionData(champData);

        const additionalData = await _champDataName(champId);
        if (additionalData && additionalData.skins) {
          const allChromas = additionalData.skins
            .map(getChromasForSkin)
            .filter(Boolean)
            .flat();
          setChampChromas(allChromas);
        }
      }
    } catch (error) {
      console.error("Error fetching champion data:", error);
    } finally {
      setIsLoading(false);
    }
  };

  async function onSelect(type, entity) {
    if (type === "champion") {
      // Switch to champions tab and select the champion
      setActiveTab('champions');
      setSelectedChampion(entity.key);
      onOpenChange(false);
    } else if (type === "skinline") {
      // Switch to champions tab (since skinlines are shown there) and select the skinline
      setActiveTab('champions');
      setSelectedSkinLine(entity.id);
      onOpenChange(false);
    } else if (type === "skin") {
      setIsLoading(true);
      const champId = splitId(entity.id)[0];
      setSelectedSkinData(entity);
      onOpenChange(false);
      setIsSkinDialogOpen(true);
      await fetchChampionData(champId);
    }
  }

  return (
    <>
      <Box className="w-full max-w-10 mx-auto">
        <Dialog.Root
          open={isOpen}
          onOpenChange={onOpenChange}
        >
          {/* Eliminar el Dialog.Trigger */}
          
          <AnimatePresence>

            <Dialog.Content className="border-none shadow-lg" maxHeight="600px" aria-describedby={undefined}>
              <Dialog.Title className="text-gray-200">Search</Dialog.Title>

              <Flex gap="4" align="start">
                <TextField.Root
                  size="3"
                  className="flex-1 bg-[#2a2a2a] text-white"
                  placeholder="Search..."
                  value={query}
                  onChange={handleSearchInput}
                  autoFocus
                >
                  <TextField.Slot>
                    <MagnifyingGlassIcon className="text-gray-400" height="16" width="16" />
                  </TextField.Slot>
                  <TextField.Slot pr="3">
                    <DropdownMenu.Root>
                      <DropdownMenu.Trigger>
                        <IconButton size="2" variant="ghost">
                          <DotsHorizontalIcon height="16" width="16" />
                        </IconButton>
                      </DropdownMenu.Trigger>
                      <DropdownMenu.Content>
                        <CheckboxGroup.Root
                          value={selectedValues}
                          onValueChange={handleFilterChange}
                          className="text-gray-200"
                        >
                          <CheckboxGroup.Item value="1">Skinlines</CheckboxGroup.Item>
                          <CheckboxGroup.Item value="2">Skins</CheckboxGroup.Item>
                          <CheckboxGroup.Item value="3">Champions</CheckboxGroup.Item>
                        </CheckboxGroup.Root>
                      </DropdownMenu.Content>
                    </DropdownMenu.Root>
                  </TextField.Slot>
                </TextField.Root>
              </Flex>

              {query.length > 0 && (
                <ScrollArea className="mt-4" type="auto" scrollbars="vertical" style={{ height: 450 }} >
                  <ResultsSection
                    title="Champions"
                    items={searchResults.champions.map(m => m.item)}
                    onSelect={onSelect}
                    selected={selected}
                  />
                  <ResultsSection
                    title="Skins"
                    items={searchResults.skins.map(m => m.item)}
                    onSelect={onSelect}
                    selected={selected}
                  />
                  <ResultsSection
                    title="Skinlines"
                    items={searchResults.skinlines.map(m => m.item)}
                    onSelect={onSelect}
                    selected={selected}
                  />
                </ScrollArea>
              )}

              <Dialog.Close className="p-3">
                <IconButton
                  size="3"
                  variant="ghost"
                  className="absolute top-2 right-2 text-gray-400 hover:text-gray-200"
                  onClick={() => onOpenChange(false)}

                >
                  <Cross2Icon />
                </IconButton>
              </Dialog.Close>
            </Dialog.Content>
          </AnimatePresence>

        </Dialog.Root>
      </Box>

      <Dialog.Root
        open={isSkinDialogOpen}
        onOpenChange={setIsSkinDialogOpen}
      >
        {selectedSkinData && (
          isLoading ? (
            <Dialog.Content maxWidth="120px" maxHeight="80px">
              <Flex direction="column" align="center" justify="center" gap="4">
                <Spinner></Spinner>
              </Flex>
            </Dialog.Content>
          ) : (
            championData && (
              <SkinDial
                skin={selectedSkinData}
                champKey={championData.key}
                asset={asset}
                rarity={rarity}
                chromas={champChromas}
              />
            )
          )
        )}
      </Dialog.Root>
    </>
  );
}
/// components End of Omnisearch.jsx ///

/// components Start of ProfileDialog.jsx ///
import {
  Flex,
  IconButton,
  Dialog,
  Box,
  Heading,
  Avatar,
  Button,
  Card,
  Text,
  Table
} from '@radix-ui/themes';
import React, { useState, useEffect } from 'react';
import { useNavigate } from "react-router-dom";
import ContainerForm from './ContainerForm';
import { useUser } from '../context/usercontext';
import { PersonIcon } from '@radix-ui/react-icons';

export const ProfileDialog = ({ userData, onLogout }) => {
  
    return (
      <Card  variant='ghost' className='max-w-96'>
        <Flex direction="column" gap="4">
          <Flex align="center" gap="3">
            <Avatar
              size="5"
              src={userData?.avatar}
              fallback={userData?.login?.[0]?.toUpperCase() || 'U'}
              radius="full"
            />
            <Box>
              <Heading as="h3" size="4">{userData?.login || 'User'}</Heading>
              <Text as="p" size="2" color="gray">{userData?.email}</Text>
            </Box>
          </Flex>
  
          <Heading as="h2" size="4">Account Details</Heading>
  
          <Table.Root>
            <Table.Body>
              <Table.Row>
                <Table.Cell>
                  <Text as="p" size="2" color="gray">Skins left</Text>
                </Table.Cell>
                <Table.Cell>
                  <Text as="p" size="2">{userData?.fichasporskin || '0'}</Text>
                </Table.Cell>
              </Table.Row>
              <Table.Row>
                <Table.Cell>
                  <Text as="p" size="2" color="gray">UID</Text>
                </Table.Cell>
                <Table.Cell>
                  <Text as="p" size="2">
                    {userData?.id || '0'}
                  </Text>
                </Table.Cell>
              </Table.Row>
            </Table.Body>
          </Table.Root>
          <Flex className='w-full h-5 p-3' justify="end" align="center">
          <Button color="red" size="3"  onClick={onLogout}>
            Logout
          </Button>
          </Flex>
        </Flex>
      </Card>
    );
};


function Profile() {

    const [loginOpen, setLoginOpen] = useState(false);
    const [profileOpen, setProfileOpen] = useState(false);
    const [currentPopup, setCurrentPopup] = useState("login");
    const { userData, setUserData } = useUser();
    const navigate = useNavigate();
    const [isLoading, setIsLoading] = useState(true);
  
    useEffect(() => {
      const fetchUserData = async () => {
          const token = localStorage.getItem("token");
  
          if (!token) {
              setIsLoading(false);
              return;
          }
  
          try {
              const response = await window.api.getUserData(token);
              if (response.success) {
                  setUserData(response.user);
              } else {
                  throw new Error(response.message);
              }
          } catch (error) {
              console.error("Error fetching user data:", error);
              if (error.message === 'No token provided' || error.message === 'Invalid token') {
                  localStorage.removeItem("token");
                  setUserData(null);
              }
          } finally {
              setIsLoading(false);
          }
      };
  
      fetchUserData();
  }, [setUserData, navigate]);
  
    const handleLogout = () => {
      localStorage.removeItem("token");
      setUserData(null);
      setProfileOpen(false);
      navigate("/");
    };
  
    const handleMenuClick = () => {
      const token = localStorage.getItem("token");
      if (token) {
        navigate("/home");
      } else {
        setLoginOpen(true);
      }
    };
  
    const isAuthenticated = !!localStorage.getItem("token");



return ( 

<>

    {/* {isAuthenticated && (
        <>
          <InstalledSkinsDialog />

        <Dialog.Root open={profileOpen} onOpenChange={setProfileOpen}>
          <Dialog.Trigger>
            <IconButton size="3" variant="soft">
              <PersonIcon width="20" height="20" />
            </IconButton>
          </Dialog.Trigger>
          <Dialog.Content aria-describedby={undefined}>
            <Dialog.Title>Profile</Dialog.Title>
            <ProfileDialog userData={userData} onLogout={handleLogout} />
          </Dialog.Content>
        </Dialog.Root>
        </>
      )} */}

        {!isAuthenticated && (
            <Dialog.Root open={loginOpen} onOpenChange={setLoginOpen}>
              <Dialog.Trigger>
              <IconButton size="3" variant="soft">
              <PersonIcon width="20" height="20" />
              </IconButton>
              </Dialog.Trigger>
              <Dialog.Content aria-describedby={undefined}>
                <ContainerForm
                  closePopup={() => setLoginOpen(false)}
                  setCurrentPopup={setCurrentPopup}
                  currentPopup={currentPopup}
                />
              </Dialog.Content>
            </Dialog.Root>
          )}
</>

);
}

export default Profile;
/// components End of ProfileDialog.jsx ///

/// components Start of RenderSkinProperties.jsx ///

/// components End of RenderSkinProperties.jsx ///

/// components Start of ScrollTop.jsx ///
import { useEffect } from 'react';
import { useLocation } from 'react-router-dom';

const ScrollToTop = () => {
  const { pathname } = useLocation();

  useEffect(() => {
    window.scrollTo({
      top: 0,
      behavior: 'smooth'
    });
  }, [pathname]);

  return null;
};

export default ScrollToTop;
/// components End of ScrollTop.jsx ///

/// components Start of SkinDial.jsx ///
import React, { memo, useState } from 'react';
import {
  Card,
  Box,
  Text,
  Dialog,
  Flex,
  Button,
  Skeleton,
  Inset,
  ScrollArea,
  Popover,
  Callout,
  IconButton,
  Separator,
  HoverCard,
  Link,
  Avatar,
  Heading,
  Tabs,
  RadioCards,

} from "@radix-ui/themes";
import { InfoCircledIcon, Cross2Icon, CircleBackslashIcon, DownloadIcon } from "@radix-ui/react-icons";
import { useUser } from "../context/usercontext";
import { useDownloadSkin  } from "../context/download";

import { rarity } from '../data/data';
import { KhadaUrl } from '../data/data';
const SkinDial = memo(({ skin, champKey, asset, rarity, chromas }) => {
  const [isLoadingDs, setIsLoadingDs] = useState(true);
  const { userData, setUserData } = useUser();

  const handleImageLoads = () => setIsLoadingDs(false);
  const filteredChromas = chromas.filter(chroma => chroma.origin === skin.id);
  const [selectedChroma, setSelectedChroma] = useState(null);
  const handleSelectChroma = (value) => {
    setSelectedChroma((prev) => (prev === value ? null : value));
  };
  const downloadSkin = useDownloadSkin();

  const handleDownload = async () => {
    const idToDownload = selectedChroma ? parseInt(selectedChroma) : skin.id;

    // Encontrar el chroma seleccionado si existe
    const selectedChromaData = selectedChroma
      ? chromas.find(chroma => String(chroma.id) === selectedChroma)
      : null;

    await downloadSkin(
      Math.floor(skin.id / 1000),
      idToDownload,
      setUserData,
      skin,
      selectedChromaData
    );
  };

  return (
      <>
      <Dialog.Content className="custom-dialog" maxWidth="850px" aria-describedby={undefined}>
        <Dialog.Title>              <Flex direction="row" align="center" mt="2">
          {rarity(skin) && (
            <img
              className="mr-2 "
              width="20"
              height="auto"
              src={rarity(skin)[0]}
              title={rarity(skin)[1]}
              alt={rarity(skin)[1]}
            />
          )}

          {skin.name}</Flex></Dialog.Title>

        <Flex
          direction={{
            md: "row",
            xl: "row",
          }}
          justify={{
            md: "space-between",
            xl: "space-between",
          }}
          align={{
            md: "start",
            xl: "start-between",
          }}
          gap="4"
          className="w-full"
          style={{ transition: 'all 1s ease-in-out' }}
        >
          {/* Skin Image and Bio */}
          <Box style={{ flex: 1, maxWidth: "100%" }}>
            <Card
              size="4"
              style={{
                width: "100%",
                maxWidth: "450px",
                padding: "1rem",
              }}
            >


              <Inset
                clip="border-box"
                side="all"
                pb="current"
                size=""
              >
                {isLoadingDs && (
                  <Box
                    className="skeleton-container bg-primary"
                    style={{
                      width: '-webkit-fill-available',
                      objectFit: "contain",
                      height: '1000px',
                      minHeight: 'auto',
                      minWidth: 'auto',
                      maxHeight: '270px'
                    }}
                  >
                    <Skeleton className="w-full h-full" />
                  </Box>
                )}
                <img
                  src={skin?.splashPath ? asset(skin.splashPath) : ""}
                  alt="Champion Splash"
                  style={{
                    display: isLoadingDs ? "none" : "block",
                    objectFit: "cover",
                    width: "-webkit-fill-available",
                    height: "270px",
                    maxHeight: "300px",
                  }}
                  onLoad={handleImageLoads}
                />
              </Inset>

              <ScrollArea
                type="auto"
                scrollbars="vertical"
                style={{
                  height: skin.description ? "auto" : "auto",
                  maxHeight: skin.description ? "130px" : "auto",
                  minHeight: "30px",

                  verticalAlign: skin.description ? "none" : "center"
                }}
              >
                <Text
                  as="p"
                  size="3"
                  className="pr-4 pt-2"
                  style={{
                    textAlign: skin.description ? "left" : "left",
                  }}
                >
                  {skin.description || "This skin does not have a description."}
                </Text>
              </ScrollArea>
            </Card>
          </Box>

          <Flex direction="column" gap="3" align="start" className="w-full" style={{ flex: 1 }}>
            {/* Difficulty */}
            <Flex direction="column" style={{ width: "100%" }}>
              <Text as="h1" size="5" mb="4">View skin on{" "}<HoverCard.Root>
                <HoverCard.Trigger>
                  <Link href={KhadaUrl(skin.id, selectedChroma)} target="_blank">
                    Model viewer
                  </Link>
                </HoverCard.Trigger>
                <HoverCard.Content maxWidth="300px">
                  <Flex gap="4">
                    <Avatar
                      size="3"
                      fallback="R"
                      radius="full"
                      src="https://modelviewer.lol/logo.svg"
                    />
                    <Box>
                      <Heading size="3" as="h3">
                        Khada
                      </Heading>
                      <Text as="div" size="2" color="gray" mb="2">
                        Model Viewer for LoL
                      </Text>
                      <Text as="div" size="2">
                        Fan-made 3D model viewer for every champion and skin from League of Legends with chromas and alternative forms!
                      </Text>
                    </Box>
                  </Flex>
                </HoverCard.Content>
              </HoverCard.Root>
                <Popover.Root>
                  <Popover.Trigger>
                    <IconButton variant="soft" ml="2" size="1">
                      <InfoCircledIcon />
                    </IconButton>
                  </Popover.Trigger>
                  <Popover.Content size="3" maxWidth="300px">
                    <Text as="p" trim="both" size="3">
                      Preview the in-game appearance of the skin.
                    </Text>
                  </Popover.Content>
                </Popover.Root></Text>


              <Separator size="4" orientation="horizontal" />
            </Flex>

            <Flex direction="column" style={{ width: "100%" }}>
              <Text as="h1" size="5">Chromas
                <Popover.Root>
                  <Popover.Trigger>
                    <IconButton ml="2" variant="soft" size="1">
                      <InfoCircledIcon />
                    </IconButton>
                  </Popover.Trigger>
                  <Popover.Content size="3" maxWidth="300px">
                    <Text as="p" trim="both" size="3">
                    Change skin colors
                    </Text>
                  </Popover.Content>
                </Popover.Root>
              </Text>
              <Tabs.Root defaultValue="circles">
                <Tabs.List>
                  <Tabs.Trigger value="circles">Circles</Tabs.Trigger>
                  <Tabs.Trigger value="images">Images</Tabs.Trigger>

                </Tabs.List>

                <Box pt="3">
                  <Tabs.Content value="circles">
                    <Text size="2">Select and Download your skin.</Text>
                    <ScrollArea type="auto" className="max-h-64 w-full border border-primary rounded-lg p-2">
                      <RadioCards.Root value={selectedChroma} onValueChange={handleSelectChroma} className="grid md:grid-flow-row md:grid-cols-[repeat(auto-fit,minmax(100px,1fr))] md:place-items-center grid-cols-[repeat(auto-fit,minmax(100px,1fr))] place-items-center gap-2">

                        <RadioCards.Item
                          key="default"
                          value={String(skin.id)}
                          className={`w-24 h-28 p-1 border border-gray-300 rounded-lg shadow-md hover:shadow-lg transition-shadow flex flex-col items-center justify-center
        ${selectedChroma === String(skin.id) ? "ring-2 ring-secondary" : ""}`}
                        >
                          <CircleBackslashIcon className="w-8 h-8 text-gray-500" />
                          <Text align="center" className="mt-2 text-sm font-medium">Default</Text>
                        </RadioCards.Item>

                        {filteredChromas.length > 0 ? (
                          filteredChromas.map((chroma) => {
                            const colors = chroma.colors || ["#000000"]; 
                            const gradient = colors.length > 1
                              ? `linear-gradient(to right bottom, ${colors[0]} 50%, ${colors[1]} 50.3%)`
                              : colors[0]; 
                            return (
                              <RadioCards.Item
                                key={chroma.id}
                                value={String(chroma.id)}
                                className={`w-24 h-28 p-1 border border-gray-300 rounded-lg shadow-md hover:shadow-lg transition-shadow flex flex-col items-center justify-center
              ${selectedChroma === String(chroma.id) ? "ring-2 ring-secondary" : ""}`}
                              >
                                <div
                                  className="w-16 h-16 rounded-full border border-gray-400"
                                  style={{ background: gradient }}
                                />

                                <Text align="center" className="mt-2 text-sm font-medium">{chroma.name}</Text>
                              </RadioCards.Item>
                            );
                          })
                        ) : (
                          <></>
                        )}
                      </RadioCards.Root>
                    </ScrollArea>
                  </Tabs.Content>

                  <Tabs.Content value="images">
                    <Text size="2">Select and Download your skin.</Text>

                    <ScrollArea type="auto" className="max-h-64 w-full border border-primary rounded-lg p-2">
                      <RadioCards.Root value={selectedChroma} onValueChange={handleSelectChroma} className="grid md:grid-flow-row md:grid-cols-[repeat(auto-fit,minmax(100px,1fr))] md:place-items-center grid-cols-[repeat(auto-fit,minmax(100px,1fr))] place-items-center gap-2">

                        <RadioCards.Item
                          key="default"
                          value={String(skin.id)}
                          className={`w-24 h-28 p-1 border border-gray-300 rounded-lg shadow-md hover:shadow-lg transition-shadow flex flex-col items-center justify-center
        ${selectedChroma === String(skin.id) ? "ring-2 ring-secondary" : ""}`}
                        >
                          <CircleBackslashIcon className="w-8 h-8 text-gray-500" />
                          <Text align="center" className="mt-2 text-sm font-medium">Default</Text>
                        </RadioCards.Item>

                        {filteredChromas.length > 0 ? (
                          filteredChromas.map((chroma) => (
                            <RadioCards.Item
                              key={chroma.id}
                              value={String(chroma.id)}
                              className={`w-24 h-28 p-1 border border-gray-300 rounded-lg shadow-md hover:shadow-lg transition-shadow flex flex-col items-center justify-center
            ${selectedChroma === String(chroma.id) ? "ring-2 ring-secondary" : ""}`}
                            >
                              <img
                                className="w-16 h-auto rounded-md"
                                src={chroma.chromaPath}
                                alt={chroma.name}
                                onLoad={handleImageLoads}
                              />
                              <Text align="center" className="mt-2 text-sm font-medium">{chroma.name}</Text>
                            </RadioCards.Item>
                          ))
                        ) : (
                          <></>
                        )}
                      </RadioCards.Root>
                    </ScrollArea>
                  </Tabs.Content>

                  <Callout.Root variant="surface" my="3">
                      <Callout.Icon>
                        <InfoCircledIcon />
                      </Callout.Icon>
                      <Callout.Text>
                        This is going to consume a credit {userData?.fichasporskin > 0 && ` (${userData.fichasporskin} credits left)`}
                      </Callout.Text>
                    </Callout.Root>

                </Box>
              </Tabs.Root>

            </Flex>

          </Flex>

        </Flex>





        {/* Close button */}
        <Flex className="relative justify-between">
          <Dialog.Close asChild>
            <Button size="3" className="m-3  relative " variant="soft" color="gray">
              Close
            </Button>

          </Dialog.Close>
          <Button onClick={handleDownload}
            disabled={!userData || userData.fichasporskin <= 0}
            size="3" color="gray" className="m-3  relative ">
            <DownloadIcon></DownloadIcon>
            Download {selectedChroma ? 'Chroma' : 'Skin'}

          </Button>
        </Flex>
      </Dialog.Content>
      </>
  );
});

export default SkinDial;

/// components End of SkinDial.jsx ///

/// components Start of SkinDialWrapper.jsx ///
import React, { useState, useEffect } from 'react';
import { _champData, _champDataName, getChromasForSkin } from '../data/data';
import SkinDial from './SkinDial'; // Asegúrate de importar SkinDial correctamente
import {
    Dialog,
    Flex,
    Spinner,
  } from '@radix-ui/themes';
const SkinDialWrapper = ({ skin, asset, rarity }) => {
  // Estados para manejar chromas, champKey y estado de carga
  const [chromas, setChromas] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [champKey, setChampKey] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      // Obtener el ID del campeón a partir del ID de la skin
      // Suponemos que skin.id tiene el formato champId * 1000 + skinId
      const champId = Math.floor(skin.id / 1000);
      try {
        const champData = await _champData(champId);
        if (champData) {
          setChampKey(champData.key); // Establecer champKey
          const additionalData = await _champDataName(champId);
          if (additionalData && additionalData.skins) {
            // Obtener todos los chromas para las skins del campeón
            const allChromas = additionalData.skins
              .map(getChromasForSkin)
              .filter(Boolean)
              .flat();
            setChromas(allChromas);
          }
        }
      } catch (error) {
        console.error("Error fetching champion data:", error);
      } finally {
        setIsLoading(false);
      }
    };
    fetchData();
  }, [skin]); // Volver a ejecutar si cambia la skin

  // Mostrar un indicador de carga mientras se obtienen los datos
  if (isLoading) {
    return (
      <Dialog.Content maxWidth="120px" maxHeight="80px">
        <Flex direction="column" align="center" justify="center" gap="4">
          <Spinner />
        </Flex>
      </Dialog.Content>
    );
  }

  // Renderizar SkinDial con los datos obtenidos
  return (
    <SkinDial
      skin={skin}
      champKey={champKey}
      asset={asset}
      rarity={rarity}
      chromas={chromas}
    />
  );
};

export default SkinDialWrapper;
/// components End of SkinDialWrapper.jsx ///

/// components Start of SkinLines.jsx ///
import React, { useState } from 'react';
import { Grid, Card, Box, Text, Avatar, Flex } from '@radix-ui/themes';
import { skinlines, skinlineSkins, asset } from '../data/data';
import { rarity } from '../data/data';
import { SkinLinesGrid } from './SkinLinesGrid';

export function SkinLinesIndex({ onSkinLineSelect }) {
  const [isLoadingIndex, setIsLoadingIndex] = useState(true);

  const handleImageLoad = () => {
    setIsLoadingIndex(false);
  };

  const getInitials = (name) => {
    return name
      .split(' ')
      .map(word => word[0])
      .join('')
      .toUpperCase()
      .slice(0, 2);
  };

  return (
    <div className='mt-[15px]'>
      <Grid className="grid grid-cols-[repeat(auto-fit,80px)] gap-3 justify-center" gap="3" width="100%" height="100%">
        {skinlines.map((skinline) => (
          <Card variant="ghost" key={skinline.id}>
            <div
              className="decoration-inherit text-ellipsis overflow-hidden text-nowrap cursor-pointer"
              title={skinline.name}
              onClick={() => onSkinLineSelect(skinline.id)}
            >
              <Box className=' h-[80px] flex items-center justify-center'>
                <Avatar
                  size="6"
                  radius="full"
                  fallback={getInitials(skinline.name)}
                />
              </Box>
              <div className="text-center mt-1 text-ellipsis overflow-hidden text-nowrap">
                <Text size="2" weight="bold">{skinline.name}</Text>
              </div>
            </div>
          </Card>
        ))}
      </Grid>
    </div>
  );
}

export function SkinLine({ skinLineId, onBack }) {
    const skinline = skinlines.find((s) => s.id === skinLineId);
    
    if (!skinline) return null;
    
    const skins = skinlineSkins(skinline.id);
  
    return (
      <div className='h-max relative mt-5'>
        <Box className='w-full'>
          <Flex display="inline-flex" direction="row" justify="center" align="center" className='items-center w-full relative mb-5'>
            <Avatar
              size="2"
              radius="full"
              fallback={skinline.name.charAt(0).toUpperCase()}
              className="mr-2"
            />
            <Text size="6" weight="bold">
              {skinline.name} Collection
            </Text>
          </Flex>
          <SkinLinesGrid skins={skins} asset={asset} rarity={rarity} />
        </Box>
      </div>
    );
  }

export default { SkinLinesIndex, SkinLine };
/// components End of SkinLines.jsx ///

/// components Start of SkinLinesGrid.jsx ///
import React, { useState, memo } from 'react';
import {
  Card,
  Box,
  Dialog,
  Flex,
  Button,
  Skeleton,
  ScrollArea,
  Callout,
  Tabs,
  RadioCards,
} from '@radix-ui/themes';
import { InfoCircledIcon, DownloadIcon } from '@radix-ui/react-icons';
import { KhadaUrl } from '../data/data';
import { useUser } from '../context/usercontext';
import { useDownloadSkin } from '../context/download';
import { motion, AnimatePresence } from 'framer-motion';
import SkinDialWrapper from './SkinDialWrapper';
import { SkinItem } from '../pages/champions';

const TabAnimation = {
  initial: { opacity: 0, y: 20 },
  animate: { opacity: 1, y: 0 },
  exit: { opacity: 0, y: -20 },
  transition: { duration: 0.3 }
};
// SkinLineItem component for individual skin items in the grid
export const SkinLineItem = memo(({ skin, asset, rarity }) => {
  const [isLoading, setIsLoading] = useState(true);

  const handleImageLoad = () => {
    setIsLoading(false);
  };

  return (
    <Box
      style={{ willChange: "transform" }}
      className="relative rounded-lg overflow-hidden hover:scale-105 transition-transform"
      key={skin.id}
    >
      <Flex
        align="center"
        direction="column"
        justify="center"
        className="items-center"
      >
        {isLoading && (
          <Skeleton>
            <Box style={{ width: "200px", height: "200px" }} />
          </Skeleton>
        )}

        <Box
          style={{
            display: isLoading ? "none" : "block",
            width: "200px",
            height: "200px",
          }}
          className="bg-primary relative"
        >
          {skin.isLegacy && (
            <div className="absolute top-2 left-2 z-10">
              <img
                width="24"
                height="24"
                src="https://raw.communitydragon.org/latest/plugins/rcp-fe-lol-static-assets/global/default/images/summoner-icon/icon-legacy.png"
                title="Legacy Skin"
                alt="Legacy Icon"
                style={{ filter: "brightness(0.8)" }}
              />
            </div>
          )}

          <img
            src={asset(skin.tilePath)}
            alt={skin.name}
            style={{
              cursor: "pointer",
              objectFit: "cover",
              width: "100%",
              height: "100%"
            }}
            onLoad={handleImageLoad}
          />
        </Box>

        <Flex 
          direction="row" 
          align="center" 
          className="w-[200px] px-2 py-1 bg-black/50 backdrop-blur-sm"
        >
          {rarity(skin) && (
            <img
              className="mr-2"
              width="16"
              height="16"
              src={rarity(skin)[0]}
              title={rarity(skin)[1]}
              alt={rarity(skin)[1]}
            />
          )}
          <span className="text-sm text-white truncate">
            {skin.name}
          </span>
        </Flex>
      </Flex>
    </Box>
  );
});

// SkinLineDialog component for the detailed view
export const SkinLineDialog = ({ skin, asset, rarity, chromas }) => {
  const [isLoadingDs, setIsLoadingDs] = useState(true);
  const [isInstalled, setIsInstalled] = useState(false);
  const [selectedChroma, setSelectedChroma] = useState(null);
  const { userData } = useUser();
  const downloadSkin = useDownloadSkin();
  const filteredChromas = chromas?.filter(chroma => chroma.origin === skin.id) || [];
  
  const handleImageLoads = () => setIsLoadingDs(false);

  
  
  const handleSelectChroma = (value) => {
    setSelectedChroma(prev => prev === value ? null : value);
  };

  const handleDownload = async () => {
    const idToDownload = selectedChroma ? parseInt(selectedChroma) : skin.id;
    const selectedChromaData = selectedChroma
      ? chromas.find(chroma => String(chroma.id) === selectedChroma)
      : null;
      
    await downloadSkin(
      Math.floor(skin.id / 1000),
      idToDownload,
      setUserData,
      skin,
      selectedChromaData
    );
  };

  return (
    <Dialog.Content className="custom-dialog" maxWidth="850px">
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: -20 }}
      >
        <Dialog.Title>
          <Flex direction="row" align="center" mt="2">
            {rarity(skin) && (
              <motion.img
                initial={{ scale: 0.8 }}
                animate={{ scale: 1 }}
                className="mr-2"
                width="20"
                height="auto"
                src={rarity(skin)[0]}
                title={rarity(skin)[1]}
                alt={rarity(skin)[1]}
              />
            )}
            {skin.name}
          </Flex>
        </Dialog.Title>

        {/* Main content structure remains similar but with animations */}
        <Flex direction={{ md: "row", xl: "row" }} gap="4" className="w-full">
          {/* Left side - Skin image and description */}
          <Box style={{ flex: 1 }}>
            <motion.div {...TabAnimation}>
              <Card size="4" style={{ width: "100%", maxWidth: "450px" }}>
                {/* Image and description content */}
              </Card>
            </motion.div>
          </Box>

          {/* Right side - Chromas and controls */}
          <Flex direction="column" gap="3" style={{ flex: 1 }}>
            <Tabs.Root defaultValue="circles">
              <Tabs.List>
                <Tabs.Trigger value="circles">Circles</Tabs.Trigger>
                <Tabs.Trigger value="images">Images</Tabs.Trigger>
              </Tabs.List>

              <AnimatePresence mode="wait">
                <Tabs.Content value="circles">
                  <motion.div {...TabAnimation}>
                    {/* Circles tab content */}
                    <ScrollArea type="auto" className="max-h-64">
                      <RadioCards.Root value={selectedChroma} onValueChange={handleSelectChroma}>
                        {/* Chroma options */}
                      </RadioCards.Root>
                    </ScrollArea>
                  </motion.div>
                </Tabs.Content>

                <Tabs.Content value="images">
                  <motion.div {...TabAnimation}>
                    {/* Images tab content */}
                    <ScrollArea type="auto" className="max-h-64">
                      <RadioCards.Root value={selectedChroma} onValueChange={handleSelectChroma}>
                        {/* Image options */}
                      </RadioCards.Root>
                    </ScrollArea>
                  </motion.div>
                </Tabs.Content>
              </AnimatePresence>
            </Tabs.Root>

            {/* Credits callout */}
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              <Callout.Root variant="surface">
                <Callout.Icon><InfoCircledIcon /></Callout.Icon>
                <Callout.Text>
                  This is going to consume a credit {userData?.fichasporskin > 0 && ` (${userData.fichasporskin} credits left)`}
                </Callout.Text>
              </Callout.Root>
            </motion.div>
          </Flex>
        </Flex>

        {/* Dialog actions */}
        <Flex className="justify-between mt-4">
          <Dialog.Close asChild>
            <Button size="3" variant="soft" color="gray">Close</Button>
          </Dialog.Close>
          
          <motion.div whileHover={{ scale: 1.05 }} whileTap={{ scale: 0.95 }}>
            <Button
              onClick={handleDownload}
              disabled={!userData || userData.fichasporskin <= 0}
              size="3"
              color="gray"
            >
              <DownloadIcon />
              Download {selectedChroma ? 'Chroma' : 'Skin'}
            </Button>
          </motion.div>
        </Flex>
      </motion.div>
    </Dialog.Content>
  );
};

export const SkinLinesGrid = ({ skins, asset, rarity }) => {
  const getChampKey = (skinId) => {
    const champId = Math.floor(skinId / 1000);
    return `champion-${champId}`; // Formato básico para el champKey
  };

  return (
    <Box className="grid grid-cols-[repeat(auto-fit,250px)] gap-3 justify-center items-center pb-7 justify-items-center">
      {skins.map((skin) => (
        <Dialog.Root key={skin.id}>
          <Dialog.Trigger asChild>
            <div className="cursor-pointer w-fit h-fit">
              {/* Usar SkinItem en lugar de SkinLineItem */}
              <SkinItem
                skin={skin}
                champKey={getChampKey(skin.id)}
                asset={asset}
                rarity={rarity}
              />
            </div>
          </Dialog.Trigger>
          <SkinDialWrapper
            skin={skin}
            asset={asset}
            rarity={rarity}
          />
        </Dialog.Root>
      ))}
    </Box>
  );
};

export default SkinLinesGrid;
/// components End of SkinLinesGrid.jsx ///

/// components Start of SkinsGrid.jsx ///
import React, { useState, useEffect, useRef, memo } from "react";
import {
  Card,
  Box,
  Text,
  Dialog,
  Flex,
  Button,
  Skeleton,
  Inset,
  ScrollArea,
  Popover,
  Callout,
  IconButton,
  Separator,
  HoverCard,
  Link,
  Avatar,
  Heading,
  Tabs,
  RadioCards,


} from "@radix-ui/themes";

import { SkinItem } from "../pages/champions";
import { InfoCircledIcon, Cross2Icon, CircleBackslashIcon, DownloadIcon, AccessibilityIcon } from "@radix-ui/react-icons";
import { KhadaUrl } from "../data/data";
import { useUser } from "../context/usercontext";
import { useDownloadSkin } from "../context/download";
import { GetInstalledSkins } from "../../wailsjs/go/main/App";
// Add this image cache to prevent reloading the same images
const imageCache = new Map();

// Create a memory-efficient dialog component
const MemoryEfficientDialog = memo(({ children, isOpen, onClose }) => {
  useEffect(() => {
    // Clean up when dialog closes
    return () => {
      if (!isOpen) {
        // Force garbage collection when dialog closes
        setTimeout(() => {
          if (window.gc) window.gc();
        }, 100);
      }
    };
  }, [isOpen]);
  
  return children;
});

// Elimina imageCache y MemoryEfficientDialog

const SkinsGrid = ({ skins, champKey, asset, rarity, chromas }) => {
  const [visibleSkins, setVisibleSkins] = useState([]);
  const allSkinsRef = useRef([]);
  const gridRef = useRef(null);

  useEffect(() => {
    allSkinsRef.current = skins.filter(skin => !skin.isBase);
    setVisibleSkins(allSkinsRef.current.slice(0, 8));

    const observer = new IntersectionObserver((entries) => {
      if (entries[0].isIntersecting) {
        setVisibleSkins(prev => {
          if (prev.length >= allSkinsRef.current.length) return prev;
          return [...prev, ...allSkinsRef.current.slice(prev.length, prev.length + 4)];
        });
      }
    }, { rootMargin: '500px' });

    if (gridRef.current) {
      observer.observe(gridRef.current);
    }

    return () => {
      if (observer) observer.disconnect();
      allSkinsRef.current = [];
      setVisibleSkins([]);
    };
  }, [skins]);

  return (
    <Box
      ref={gridRef}
      className="grid grid-cols-[repeat(auto-fit,250px)] gap-3 justify-center items-center pb-7 justify-items-center"
    >
      {visibleSkins.map((skin) => (
        <Dialog.Root key={skin.id}>
          <Dialog.Trigger asChild>
            <div className="cursor-pointer w-fit h-fit">
              <SkinItem
                skin={skin}
                champKey={champKey}
                asset={asset}
                rarity={rarity}
              />
            </div>
          </Dialog.Trigger>
          <Dialog.Content>
            <SkinDialog
              skin={skin}
              champKey={champKey}
              asset={asset}
              rarity={rarity}
              chromas={chromas}
            />
          </Dialog.Content>
        </Dialog.Root>
      ))}

      {visibleSkins.length < allSkinsRef.current.length && (
        <div className="col-span-full flex justify-center py-4">
          <Skeleton>
            <Box style={{ width: "200px", height: "10px" }} />
          </Skeleton>
        </div>
      )}
    </Box>
  );
};

// Optimize SkinDialog component
const SkinDialog = memo(({ skin, champKey, asset, rarity, chromas }) => {
  const [isLoadingDs, setIsLoadingDs] = useState(true);
  const [isInstalled, setIsInstalled] = useState(false);
  const { userData, setUserData } = useUser();
  const downloadSkin = useDownloadSkin();
  const handleImageLoads = () => setIsLoadingDs(false);
  const filteredChromas = chromas.filter(chroma => chroma.origin === skin.id);
  const [selectedChroma, setSelectedChroma] = useState(null);

  useEffect(() => {
    async function checkInstallation() {
      try {
        const installedSkins = await GetInstalledSkins();
        if (!installedSkins) {
          setIsInstalled(false);
          return;
        }
        if (!Array.isArray(installedSkins)) {
          console.error("Installed skins data is not an array:", installedSkins);
          setIsInstalled(false);
          return;
        }
        setIsInstalled(installedSkins.some(installedSkin => 
          installedSkin.championId === String(Math.floor(skin.id / 1000))
        ));
      } catch (error) {
        console.error("Error checking installation:", error);
      }
    }
    checkInstallation();
  }, [skin.id]);


  
  const handleSelectChroma = (value) => {
    setSelectedChroma((prev) => (prev === value ? null : value));
  };

  // In the handleDownload function of SkinDialog component
  const handleDownload = async () => {
    const idToDownload = selectedChroma ? parseInt(selectedChroma) : skin.id;
  
    const selectedChromaData = selectedChroma
      ? chromas.find(chroma => String(chroma.id) === selectedChroma)
      : null;
  
    // Update global status
    if (window.updateGlobalStatus) {
      window.updateGlobalStatus(`Installing ${selectedChromaData ? 'chroma' : 'skin'}: ${skin.name}`);
    }
  
    await downloadSkin(
      Math.floor(skin.id / 1000),
      idToDownload,
      setUserData,
      skin,
      selectedChromaData
    );
  
    // Update global status after download
    if (window.updateGlobalStatus) {
      window.updateGlobalStatus(`Installed ${selectedChromaData ? 'chroma' : 'skin'}: ${skin.name}`);
    }
  };
  
  // Similarly in handleUninstall
  const handleUninstall = async () => {
    const loadingToast = toast.loading('Uninstalling skin...');
    try {
      const championId = Math.floor(skin.id / 1000);
      
      // Update global status
      if (window.updateGlobalStatus) {
        window.updateGlobalStatus(`Uninstalling skin: ${skin.name}`);
      }
      
      const result = await window.modTools.uninstallSkin(championId);
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to uninstall skin');
      }
  
      setIsInstalled(false);
      toast.dismiss(loadingToast);
      toast.success('Skin uninstalled successfully');
  
      // Update global status after uninstall
      if (window.updateGlobalStatus) {
        window.updateGlobalStatus(`Uninstalled skin: ${skin.name}`);
      }
    } catch (error) {
      toast.dismiss(loadingToast);
      toast.error(error.message || 'Failed to uninstall skin');
    }
  };

  

  return (
    <>





      <Dialog.Content className="custom-dialog" maxWidth="850px" aria-describedby={undefined}>
        <Dialog.Title>              <Flex direction="row" align="center" mt="2">
          {rarity(skin) && (
            <img
              className="mr-2 "
              width="20"
              height="auto"
              src={rarity(skin)[0]}
              title={rarity(skin)[1]}
              alt={rarity(skin)[1]}
            />
          )}

          {skin.name}</Flex></Dialog.Title>

        <Flex
          direction={{
            md: "row",
            xl: "row",
          }}
          justify={{
            md: "space-between",
            xl: "space-between",
          }}
          align={{
            md: "start",
            xl: "start-between",
          }}
          gap="4"
          className="w-full"
          style={{ transition: 'all 1s ease-in-out' }}
        >
          {/* Skin Image and Bio */}
          <Box style={{ flex: 1, maxWidth: "100%" }}>
            <Card
              size="4"
              style={{
                width: "100%",
                maxWidth: "450px",
                padding: "1rem",
              }}
            >


              <Inset
                clip="border-box"
                side="all"
                pb="current"
                size=""
              >
                {isLoadingDs && (
                  <Box
                    className="skeleton-container bg-primary"
                    style={{
                      width: '-webkit-fill-available',
                      objectFit: "contain",
                      height: '1000px',
                      minHeight: 'auto',
                      minWidth: 'auto',
                      maxHeight: '270px'
                    }}
                  >
                    <Skeleton className="w-full h-full" />
                  </Box>
                )}
                <img
                  src={skin?.splashPath ? asset(skin.splashPath) : ""}
                  alt="Champion Splash"
                  style={{
                    display: isLoadingDs ? "none" : "block",
                    objectFit: "cover",
                    width: "-webkit-fill-available",
                    height: "270px",
                    maxHeight: "300px",
                  }}
                  onLoad={handleImageLoads}
                />
              </Inset>

              <ScrollArea
                type="auto"
                scrollbars="vertical"
                style={{
                  height: skin.description ? "auto" : "auto",
                  maxHeight: skin.description ? "130px" : "auto",
                  minHeight: "30px",

                  verticalAlign: skin.description ? "none" : "center"
                }}
              >
                <Text
                  as="p"
                  size="3"
                  className="pr-4 pt-2"
                  style={{
                    textAlign: skin.description ? "left" : "left",
                  }}
                >
                  {skin.description || "This skin does not have a description."}
                </Text>
              </ScrollArea>

            </Card>
            <Callout.Root variant="soft" my="3" size="1" color="yellow">
                      <Callout.Icon>
                        <AccessibilityIcon />
                      </Callout.Icon>
                      <Callout.Text>
                      This skin may not work properly due to game updates
                      </Callout.Text>
                    </Callout.Root>
          </Box>

          <Flex direction="column" gap="3" align="start" className="w-full" style={{ flex: 1 }}>
            {/* Difficulty */}
            <Flex direction="column" style={{ width: "100%" }}>
              <Text as="h1" size="5" mb="4">View skin on{" "}<HoverCard.Root>
                <HoverCard.Trigger>
                  <Link href={KhadaUrl(skin.id, selectedChroma)} target="_blank">
                    Model viewer
                  </Link>
                </HoverCard.Trigger>
                <HoverCard.Content maxWidth="300px">
                  <Flex gap="4">
                    <Avatar
                      size="3"
                      fallback="R"
                      radius="full"
                      src="https://modelviewer.lol/logo.svg"
                    />
                    <Box>
                      <Heading size="3" as="h3">
                        Khada
                      </Heading>
                      <Text as="div" size="2" color="gray" mb="2">
                        Model Viewer for LoL
                      </Text>
                      <Text as="div" size="2">
                        Fan-made 3D model viewer for every champion and skin from League of Legends with chromas and alternative forms!
                      </Text>
                    </Box>
                  </Flex>
                </HoverCard.Content>
              </HoverCard.Root>
                <Popover.Root>
                  <Popover.Trigger>
                    <IconButton variant="soft" ml="2" size="1">
                      <InfoCircledIcon />
                    </IconButton>
                  </Popover.Trigger>
                  <Popover.Content size="3" maxWidth="300px">
                    <Text as="p" trim="both" size="3">
                      Preview the in-game appearance of the skin.
                    </Text>
                  </Popover.Content>
                </Popover.Root></Text>


              <Separator size="4" orientation="horizontal" />
            </Flex>

            <Flex direction="column" style={{ width: "100%" }}>
              <Text as="h1" size="5">Chromas
                <Popover.Root>
                  <Popover.Trigger>
                    <IconButton ml="2" variant="soft" size="1">
                      <InfoCircledIcon />
                    </IconButton>
                  </Popover.Trigger>
                  <Popover.Content size="3" maxWidth="300px">
                    <Text as="p" trim="both" size="3">
                    Change skin colors
                    </Text>
                  </Popover.Content>
                </Popover.Root>
              </Text>
              <Tabs.Root defaultValue="circles">
                <Tabs.List>
                  <Tabs.Trigger value="circles">Circles</Tabs.Trigger>
                  <Tabs.Trigger value="images">Images</Tabs.Trigger>

                </Tabs.List>

                <Box pt="3">
                  <Tabs.Content value="circles">
                    <Text size="2">Select and Download your skin.</Text>
                    <ScrollArea type="auto" className="max-h-64 w-full border border-primary rounded-lg p-2">
                      <RadioCards.Root value={selectedChroma} onValueChange={handleSelectChroma} className="grid md:grid-flow-row md:grid-cols-[repeat(auto-fit,minmax(100px,1fr))] md:place-items-center grid-cols-[repeat(auto-fit,minmax(100px,1fr))] place-items-center gap-2">

                        {/* Opción Default */}
                        <RadioCards.Item
                          key="default"
                          value={String(skin.id)}
                          className={`w-24 h-28 p-1 border border-gray-300 rounded-lg shadow-md hover:shadow-lg transition-shadow flex flex-col items-center justify-center
                        ${selectedChroma === String(skin.id) ? "ring-2 ring-secondary" : ""}`}
                        >
                          <CircleBackslashIcon className="w-8 h-8 text-gray-500" />
                          <Text align="center" className="mt-2 text-sm font-medium">Default</Text>
                        </RadioCards.Item>

                        {/* Chromas map */}
                        {filteredChromas.length > 0 ? (
                          filteredChromas.map((chroma) => {
                            const colors = chroma.colors || ["#000000"]; 
                            const gradient = colors.length > 1
                              ? `linear-gradient(to right bottom, ${colors[0]} 50%, ${colors[1]} 50.3%)`
                              : colors[0]; 
                            return (
                              <RadioCards.Item
                                key={chroma.id}
                                value={String(chroma.id)}
                                className={`w-24 h-28 p-1 border border-gray-300 rounded-lg shadow-md hover:shadow-lg transition-shadow flex flex-col items-center justify-center
              ${selectedChroma === String(chroma.id) ? "ring-2 ring-secondary" : ""}`}
                              >
                                <div
                                  className="w-16 h-16 rounded-full border border-gray-400"
                                  style={{ background: gradient }}
                                />

                                <Text align="center" className="mt-2 text-sm font-medium">{chroma.name}</Text>
                              </RadioCards.Item>
                            );
                          })
                        ) : (
                          <></>
                        )}
                      </RadioCards.Root>
                    </ScrollArea>

                  </Tabs.Content>

                  <Tabs.Content value="images">
                    <Text size="2">Select and Download your skin.</Text>

                    <ScrollArea type="auto" className="max-h-64 w-full border border-primary rounded-lg p-2">
                      <RadioCards.Root value={selectedChroma} onValueChange={handleSelectChroma}  className="grid md:grid-flow-row md:grid-cols-[repeat(auto-fit,minmax(100px,1fr))] md:place-items-center grid-cols-[repeat(auto-fit,minmax(100px,1fr))] place-items-center gap-2">

                        <RadioCards.Item
                          key="default"
                          value={String(skin.id)}
                          className={`w-24 h-28 p-1 border border-gray-300 rounded-lg shadow-md hover:shadow-lg transition-shadow flex flex-col items-center justify-center
        ${selectedChroma === String(skin.id) ? "ring-2 ring-secondary" : ""}`}
                        >
                          <CircleBackslashIcon className="w-8 h-8 text-gray-500" />
                          <Text align="center" className="mt-2 text-sm font-medium">Default</Text>
                        </RadioCards.Item>

                        {filteredChromas.length > 0 ? (
                          filteredChromas.map((chroma) => (
                            <RadioCards.Item
                              key={chroma.id}
                              value={String(chroma.id)}
                              className={`w-24 h-28 p-1 border border-gray-300 rounded-lg shadow-md hover:shadow-lg transition-shadow flex flex-col items-center justify-center
            ${selectedChroma === String(chroma.id) ? "ring-2 ring-secondary" : ""}`}
                            >
                              <img
                                className="w-16 h-auto rounded-md"
                                src={chroma.chromaPath}
                                alt={chroma.name}
                                onLoad={handleImageLoads}
                              />
                              <Text align="center" className="mt-2 text-sm font-medium">{chroma.name}</Text>
                            </RadioCards.Item>
                          ))
                        ) : (
                          <></>
                        )}
                      </RadioCards.Root>
                    </ScrollArea>
                    
                  </Tabs.Content>

                  <Callout.Root variant="surface" my="3">
                      <Callout.Icon>
                        <InfoCircledIcon />
                      </Callout.Icon>
                      <Callout.Text>
                        This is going to consume a credit {userData?.fichasporskin > 0 && ` (${userData.fichasporskin} credits left)`}
                      </Callout.Text>
                    </Callout.Root>
                </Box>
              </Tabs.Root>

            </Flex>

          </Flex>

        </Flex>





        {/* Close button */}
        <Flex className="relative justify-between">
        <Dialog.Close asChild>
          <Button size="3" className="m-3 relative" variant="soft" color="gray">
            Close
          </Button>
        </Dialog.Close>
        
        {isInstalled ? (
          <Button 
            onClick={handleUninstall}
            disabled={!userData || userData.fichasporskin <= 0 || isInstalled}

            size="3" 
            color="red" 
            className="m-3 relative"
          >
            <Cross2Icon />
            Uninstall Skin
          </Button>
        ) : (
          <Button 
            onClick={handleDownload}
            disabled={!userData || userData.fichasporskin <= 0}
            size="3" 
            color="gray" 
            className="m-3 relative"
          >
            <DownloadIcon />
            Download {selectedChroma ? 'Chroma' : 'Skin'}
          </Button>
        )}
      </Flex>
      </Dialog.Content>
    </>
  );
}
);

export { SkinsGrid, SkinDialog };

/// components End of SkinsGrid.jsx ///

/// config Start of axios.js ///
import axios from 'axios';

axios.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);
axios.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401 || error.response?.status === 403) {
      localStorage.removeItem('token');
      // Opcional: redirigir al login
    }
    return Promise.reject(error);
  }
);

export default axios;
/// config End of axios.js ///

/// context Start of download.jsx ///
//@download.jsx
import { toast } from 'sonner';
import { useUser } from '../context/usercontext';
import { GetUserData, InstallSkin, DownloadSkin } from '../../wailsjs/go/main/App';

export const useDownloadSkin = () => {
  const { revalidateUser } = useUser();

  const sanitizeFileName = (name) => {
    return name
      .replace(/[^a-z0-9\s-]/gi, '')
      .replace(/\s+/g, '-')
      .toLowerCase();
  };

  const generateFileName = (skin, chromaName = null) => {
    const baseName = sanitizeFileName(skin);
    const chromaPart = chromaName ? `-${sanitizeFileName(chromaName)}` : '';
    return `${baseName}${chromaPart}.fantome`;
  };
  
  const sanitizeImageUrl = (url) => {
    if (!url) return '';
    const baseUrl = 'https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/v1/champions/';
    if (url.startsWith(baseUrl)) {
         return url.substring(baseUrl.length);
       }
      return url; 
  };

const downloadSkin = async (championId, skinId, setUserData, skin, selectedChroma) => {
  const loadingToast = toast.loading('Processing download...');

  try {
    const token = localStorage.getItem("token");

    if (!token) {
      toast.dismiss(loadingToast);
      toast.error("You are not authenticated. Please log in to continue.");
      return;
    }

    const userResponse = await GetUserData(token);
    const userData = userResponse.user;

    if (!userData) {
      toast.dismiss(loadingToast);
      toast.error("User not found. Please log in again.");
      return;
    }

    if (userData.fichasporskin <= 0) {
      toast.dismiss(loadingToast);
      toast.error("Insufficient credits. Please purchase more.");
      return;
    }

    const skinNum = skinId % 1000;
    const chromaName = selectedChroma ? selectedChroma.name : null;
    const imageUrl = skin.tilePath;
    const baseSkinName = skin.name;
    const fileName = generateFileName(baseSkinName, chromaName);
    const sanitizedImageUrl = sanitizeImageUrl(imageUrl);

    console.log("Downloading skin with parameters:", {
      championId: String(Math.floor(skinId / 1000)),
      skinNum: String(skinNum),
      userId: String(userData.id),
      token: token,
      skinName: String(skin.name),
      fileName: String(fileName),
      chromaName: chromaName || "",
      sanitizedImageUrl: String(sanitizedImageUrl),
      baseSkinName: String(baseSkinName),
    });

    // Descargar skin
    const downloadResponse = await DownloadSkin(
      String(Math.floor(skinId / 1000)),
      String(skinNum),
      String(userData.id),
      token,
      String(skin.name),
      String(fileName),
      chromaName || "",
      String(sanitizedImageUrl),
      String(baseSkinName)
    );
    console.log("Download response:", downloadResponse);

    if (!downloadResponse.success) {
      throw new Error(downloadResponse.error || "Failed to download skin");
    }

    toast.dismiss(loadingToast);
    const installingToast = toast.loading('Installing skin...');

    try {
      // Instalar skin
      const installResult = await InstallSkin(
        String(championId),
        String(skinId),
        String(fileName),
        chromaName || "",
        String(sanitizedImageUrl),
        String(baseSkinName)
      );

      if (!installResult.success) {
        throw new Error(installResult.error || 'Failed to install skin');
      }

      toast.dismiss(installingToast);
      toast.success(`${selectedChroma ? 'Chroma' : 'Skin'} installed successfully!`);

      // Actualizar datos del usuario
      await revalidateUser();
      const refreshedResponse = await GetUserData(token);
      if (refreshedResponse.user) {
        setUserData(refreshedResponse.user);
      }
    } catch (installError) {
      toast.dismiss(installingToast);
      throw new Error(`Installation failed: ${installError.message}`);
    }
  } catch (error) {
    console.error('Download/Install error:', error);
    toast.dismiss(loadingToast);
    toast.error(error.message || "An unexpected error occurred.");
  }
};

return downloadSkin;
}
/// context End of download.jsx ///

/// context Start of usercontext.jsx ///
import { createContext, useContext, useState, useEffect, useRef } from 'react';
import { toast } from 'sonner';
import { GetUserData } from '../../wailsjs/go/main/App';

const UserContext = createContext();

export function UserProvider({ children }) {
  const [userData, setUserData] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [revalidationCount, setRevalidationCount] = useState(0);
  const isFirstLoad = useRef(true);

  const revalidateUser = () => {
    setRevalidationCount(prev => prev + 1);
  };

  useEffect(() => {
    const initializeAuth = async () => {
      const token = localStorage.getItem('token');
      
      if (!token) {
        setIsLoading(false);
        return;
      }

      const fetchUser = async () => {
        const response = await GetUserData(token);
        return { data: response }; // Mantener estructura similar a axios para compatibilidad
      };

      if (isFirstLoad.current) {
        isFirstLoad.current = false;
        setTimeout(() => {
          toast.promise(
            fetchUser(),
            {
              loading: 'Loading user data...',
              success: (response) => {
                if (response.data.success) {
                  setUserData(response.data.user);
                  return `Welcome back, ${response.data.user.login}!`;
                }
                throw new Error(response.data.error || 'Failed to load user data');
              },
              error: (error) => {
                console.error('Error initializing auth:', error);
                localStorage.removeItem('token');
                return 'Failed to load user data. Please log in again.';
              },
              finally: () => {
                setIsLoading(false);
              }
            }
          );
        });
      } else {
        try {
          const response = await fetchUser();
          if (response.data.success) {
            setUserData(response.data.user);
          } else {
            throw new Error(response.data.error || 'Failed to load user data');
          }
        } catch (error) {
          console.error('Error initializing auth:', error);
          localStorage.removeItem('token');
          toast.error('Session expired. Please log in again.');
        } finally {
          setIsLoading(false);
        }
      }
    };

    initializeAuth();
  }, [revalidationCount]);

  const value = {
    userData,
    setUserData,
    isLoading,
    revalidateUser
  };

  return (
    <UserContext.Provider value={value}>
      {!isLoading && children}
    </UserContext.Provider>
  );
}

export function useUser() {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within a UserProvider');
  }
  return context;
}
/// context End of usercontext.jsx ///

/// data Start of data.js ///
export const champions = [];
export const skinlines = [];
export const skins = {};
export let v = "";
import { FetchChampionJson } from "../../wailsjs/go/main/App";
const root = `https://raw.communitydragon.org/latest`,
  dataRoot = `${root}/plugins/rcp-be-lol-game-data/global/default`,
  dataRootFe = `${root}/plugins/rcp-fe-lol-champion-details`;




export const _champData = async (champId = null) => {


  if (champId) {

    const champDataUrl = `${dataRoot}/v1/champions/${champId}.json`;
    try {
      const response = await fetch(champDataUrl);
      if (!response.ok) {
        throw new Error(`Error al obtener datos del campeón: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      console.error(error.message);
      return null;
    }
  }


};



// export const _champDataName = async (champId = null) => {
//   if (!champId) return null;

//   try {
//     const basePath = window.electron.getChampionsPath(); // Obtiene la ruta absoluta
//     const response = await fetch(`file://${basePath}/${champId}.json`);

//     if (!response.ok) throw new Error("Not found");

//     return await response.json();
//   } catch (error) {
//     console.error(`Error: Champion Not found "${champId}".`, error);
//     return null;
//   }
// };



export const _champDataName = async (champId = null) => {
  if (!champId) return null;

  try {
    const response = await FetchChampionJson(String(champId));
    
    if (!response || !response.success) {
      throw new Error(`Error: Champion Not found "${champId}".`);
    }
    
    return response.data;
  } catch (error) {
    console.error(`Error: Champion Not found "${champId}".`, error);
    return null;
  }
};




export const _champChromas = async (champId = null) => {


  if (champId) {
    const proxyUrl = "https://cors-anywhere.herokuapp.com/";

    const champDataUrl = `https://cdn.merakianalytics.com/riot/lol/resources/latest/en-US/champions/${champId}.json`;
    try {
      const response = await fetch(proxyUrl + champDataUrl)

      if (!response.ok) {
        throw new Error(`Error al obtener datos del campeón: ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      console.error(error.message);
      return null;
    }
  }


};


export const _ready = (async () => {
  const version = await fetch(`${root}/content-metadata.json`, {
    method: "GET",
    cache: "no-cache",
  }).then((r) => r.json());
  v = version.version;
  const cacheBreak = `?${encodeURIComponent(version.version)}`;

  await Promise.all([
    fetch(`${dataRoot}/v1/champion-summary.json${cacheBreak}`)
      .then((res) => res.json())
      .then((data) =>
        data
          .filter((d) => d.id !== -1)
          .sort((a, b) => (a.name > b.name ? 1 : -1))
          .map((a) => ({ ...a, key: a.alias.toLowerCase() }))
      )
      .then((data) => champions.push(...data)),
    fetch(`${dataRoot}/v1/skinlines.json${cacheBreak}`)
      .then((res) => res.json())
      .then((data) =>
        data
          .filter((d) => d.id !== 0)
          .sort((a, b) => (a.name > b.name ? 1 : -1))
      )
      .then((data) => skinlines.push(...data)),
    fetch(`${dataRoot}/v1/skins.json${cacheBreak}`)
      .then((res) => res.json())
      .then((data) => Object.assign(skins, data)),
  ]).then(() => true);
  return true;
})();

export function splitId(id) {
  return [Math.floor(id / 1000), id % 1000];
}

export function championSkins(id) {
  return Object.values(skins).filter((skin) => splitId(skin.id)[0] === id);
}

export function getChromasForSkin(skin) {
  if (!skin) {
    return null;
  }
  if (!skin.chromas || !Array.isArray(skin.chromas) || skin.chromas.length === 0) {
    return null;
  }
  return skin.chromas
    .filter(chroma => chroma && chroma.name && chroma.id)
    .map(chroma => ({
      origin: skin.id,
      name: chroma.name,
      id: chroma.id,
      chromaPath: chroma.chromaPath ? asset(chroma.chromaPath) : null,
      colors: chroma.colors || []
    }));
}


export function skinlineSkins(id) {
  return Object.values(skins)
    .filter((skin) => skin.skinLines?.some((line) => line.id === id))
    .sort((a, b) => {
      const aId = splitId(a.id)[0];
      const bId = splitId(b.id)[0];
      const aIndex = champions.findIndex((c) => c.id === aId);
      const bIndex = champions.findIndex((c) => c.id === bId);
      return aIndex - bIndex;
    });
}

export function asset(path) {
  return path.replace("/lol-game-data/assets", dataRoot).toLowerCase();
}

const rarities = {
  kUltimate: ["ultimate.png", "Ultimate"],
  kMythic: ["mythic.png", "Mythic"],
  kLegendary: ["legendary.png", "Legendary"],
  kEpic: ["epic.png", "Epic"],
  kTranscendent: ["transcendent.png", "Transcendent"],
  kExalted: ["exalted.png", "exalted"],

};

const damages = {
  kPhysic: ["kPhysic.png", "Physic"],
  kMixed: ["kMixed.png", "Mixed"],
  kMagic: ["kMagic.png", "Magic"],
}

const styles = {

  kASGrey: ["continuum_icon_attackspeed_grey.png", "Attack"],
  kASHighlight: ["continuum_icon_attackspeed.png", "Attack"],
  kAPGrey: ["continuum_icon_abilitypower_grey.png", "Magic"],
  kMagicHighlight: ["continuum_icon_abilitypower.png", "Magic"],
}

const legacyConfig = {
  legacyItems: ["icon-legacy.png", "Legacy"]
};

export function checkLegacy(skin) {
  if (Boolean(skin?.isLegacy)) {
    return [
      `https://raw.communitydragon.org/latest/plugins/rcp-fe-lol-static-assets/global/default/images/summoner-icon/${legacyConfig.legacyItems[0]}`,
      legacyConfig.legacyItems[1]
    ];
  }
  return null;
}

export function debugLegacySkins(skins) {
  const skinsInfo = skins.map(skin => ({
    name: skin.name,
    isLegacy: Boolean(skin.isLegacy)
  }));
  console.log("Skins cargadas:", skinsInfo);
}

export function rarity(skin) {
  if (!rarities[skin.rarity]) return null;
  const [imgName, name] = rarities[skin.rarity];
  const imgUrl = `${dataRoot}/v1/rarity-gem-icons/${imgName}`;
  return [imgUrl, name];
}

export function damageType(type) {
  if (!damages[type.damage_type]) return null;
  const [imgName, name] = damages[type.damage_type];
  const imgUrl = `${dataRootFe}/v1/rarity-gem-icons/${imgName}`;
  return [imgUrl, name];
}

export function style(s) {
  if (!styles[s.tipo]) {
    return ["default-icon.png", "Unknown"];
  }
  const [imgName, name] = styles[s.tipo];
  const imgUrl = `${dataRootFe}/global/default/${imgName}`;
  return [imgUrl, name];
}
// global/default/

export function KhadaUrl(skin, chroma) {
  if (chroma && skin !== chroma) {
    return `https://modelviewer.lol/model-viewer?id=${skin}&chroma=${chroma}`;
  }
  return `https://modelviewer.lol/model-viewer?id=${skin}`;
}

/// data End of data.js ///

/// data Start of electron.js ///
//@electron.js

import { app, BrowserWindow, ipcMain } from 'electron';
import path from 'path';
import { fileURLToPath } from 'url';
import { spawn } from 'child_process';
import fs from 'fs/promises';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const BASE_PATH = app.isPackaged
  ? path.join(process.resourcesPath)  // En producción, apunta a 'resources'
  : path.join(__dirname, '..');       // En desarrollo, apunta al código fuente

// Rutas dentro de resources
const INSTALLED_PATH = path.join(BASE_PATH, 'LoLModInstaller', 'installed');
const PROFILES_PATH = path.join(BASE_PATH, 'LoLModInstaller', 'profiles', 'Default');
const MOD_TOOLS_PATH = path.join(BASE_PATH, 'cslol-tools', 'mod-tools.exe');
const MOD_STATUS_PATH = path.join(BASE_PATH, 'LoLModInstaller', 'mod-status.json');
const INSTALLED_JSON_PATH = path.join(INSTALLED_PATH, 'installed.json'); // Corregido: Ya no incluye 'installed.json' dos veces
const GAME_PATH = 'C:\\Riot Games\\League of Legends\\Game';

let mainWindow;
let modToolsProcess = null;
let installedSkins = new Map();

function createWindow() {
  mainWindow = new BrowserWindow({
    maxWidth: 1200,
    maxHeight: 800,
    minWidth: 800,
    minHeight: 700,
    width: 800,
    height: 700,
    darkTheme: true,
    titleBarStyle: 'hidden',
    titleBarOverlay: true,
    titleBarOverlay: {
      color: "#00000000", // Transparente (RGBA)
      symbolColor: "#FFFFFF" // Color de los botones de control (Cerrar, Minimizar, Maximizar)
    },
    webPreferences: {
      contextIsolation: true,
      nodeIntegration: true,
      preload: path.join(BASE_PATH, "app", "dist" , 'preload.cjs'),
      backgroundThrottling: false
    }
  });

  mainWindow.loadFile(path.join(BASE_PATH, "app", 'build', 'index.html'));

  mainWindow.on('closed', function () {
    mainWindow = null;
  });
}

async function ensureDirectories() {
  try {
    await fs.mkdir(INSTALLED_PATH, { recursive: true });
    console.log(`Created directory: ${INSTALLED_PATH}`);
    
    await fs.mkdir(PROFILES_PATH, { recursive: true });
    console.log(`Created directory: ${PROFILES_PATH}`);
    
    await fs.mkdir(path.dirname(MOD_STATUS_PATH), { recursive: true });
    console.log(`Created directory: ${path.dirname(MOD_STATUS_PATH)}`);
    
    // Log the actual paths to verify they're correct
    console.log('BASE_PATH:', BASE_PATH);
    console.log('INSTALLED_PATH:', INSTALLED_PATH);
    console.log('MOD_STATUS_PATH:', MOD_STATUS_PATH);
    console.log('INSTALLED_JSON_PATH:', INSTALLED_JSON_PATH);
  } catch (error) {
    console.error('Error ensuring directories:', error);
  }
}

async function ensureModStatusDirectory() {
  try {
    await fs.mkdir(path.dirname(MOD_STATUS_PATH), { recursive: true });
    console.log(`Created mod status directory: ${path.dirname(MOD_STATUS_PATH)}`);
  } catch (error) {
    console.error('Error creating mod status directory:', error);
  }
}

async function loadInstalledSkins() {
  try {
    const data = await fs.readFile(INSTALLED_JSON_PATH, 'utf8');
    const skinsArray = JSON.parse(data);
    installedSkins = new Map(
      skinsArray.map(skin => [skin.championId, {
        skinId: skin.skinId,
        fileName: skin.fileName,
        processId: skin.processId,
        chromaName: skin.chromaName,
          skinName: skin.skinName // Load Skin Name
      }])
    );
    console.log('Loaded installed skins from:', INSTALLED_JSON_PATH);
  } catch (err) {
    console.log('No existing installed skins found, starting fresh:', INSTALLED_JSON_PATH);
    installedSkins = new Map();
  }
}

async function saveInstalledSkins() {
  try {
    const skinsArray = Array.from(installedSkins.entries()).map(([championId, data]) => ({
      championId,
      ...data
    }));
    await fs.writeFile(
      INSTALLED_JSON_PATH,
      JSON.stringify(skinsArray, null, 2)
    );
    console.log('Saved installed skins to:', INSTALLED_JSON_PATH);
  } catch (error) {
    console.error('Error saving installed skins:', error);
  }
}

async function killProcess(processName) {
  try {
    await execAsync(`taskkill /F /IM "${processName}" /T`);
    return true;
  } catch (error) {
    console.error(`Failed to kill ${processName}:`, error);
    return false;
  }
}

async function killModTools() {
  if (modToolsProcess) {
    try {
      // Enviar señal SIGINT (equivalente a Ctrl+C)
      process.kill(modToolsProcess.pid, 'SIGINT');

      // Esperar a que el proceso se cierre limpiamente
      await new Promise(resolve => setTimeout(resolve, 1000));

      // Verificar si el proceso aún está vivo
      try {
        process.kill(modToolsProcess.pid, 0);
        await killProcess('mod-tools.exe');
      } catch (e) {
        // El proceso ya está cerrado
      }

      modToolsProcess = null;
      return true;
    } catch (error) {
      console.error('Error killing mod-tools process:', error);
      return false;
    }
  }
  return true;
}

async function waitForFileUnlock(filePath, maxAttempts = 5) {
  for (let i = 0; i < maxAttempts; i++) {
    try {
      const fileHandle = await fs.open(filePath, 'r+');
      await fileHandle.close();
      return true;
    } catch (error) {
      if (i === maxAttempts - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  return false;
}

function sendStatusUpdate(status) {
  if (mainWindow) {
    console.log("Sending status to frontend:", status); // DEBUG
    mainWindow.webContents.send('status-update', status);
  }
}

function filterAndFormatOutput(output) {
  return output
    .split("\n")
    .map(line => line.trim()) // Eliminar espacios en blanco
    .filter(line => {
      return !(
        line.includes("[DLL] info: Init in process!") ||
        line.includes("[DLL] info: patching module") ||
        line.includes("[DLL] info: Kernel32 module") ||
        line.includes("[DLL] info: Hoking CreateFileA") ||
        line.includes("[INF] Done!") 
      );
    })
    .map(line => {
      // Reemplazar "redirected wad" por "Hunted wad"
      let match = line.match(/redirected wad: .*\/([^\/]+\.wad\.client)/);
      if (match) return `Hunted wad: ${match[1]}`;

      // Reemplazar "[INF] Writing wad" por "Hunted wad"
      match = line.match(/\[INF\] Writing wad: .*\/([^\/]+\.wad\.client)/);
      if (match) return `Hunted wad: ${match[1]}`;

      return line;
    })
    .filter(line => line.length > 0) // Eliminar líneas vacías
    .join("\n");
}

function runModToolCommand(command, args) {
  return new Promise((resolve, reject) => {
    const process = spawn(MOD_TOOLS_PATH, [command, ...args]);
    let stdout = "";
    let stderr = "";

    process.stdout.on("data", (data) => {
      let output = data.toString().trim(); // Convertir a string y limpiar espacios
      if (!output) return; // Si está vacío, no hacer nada
    
      const filteredOutput = filterAndFormatOutput(output); // Aplicar filtro
      if (!filteredOutput) return; // Si el filtrado elimina todo, no hacer nada
    
      // Enviar cada línea por separado
      filteredOutput.split("\n").forEach(line => {
        console.log(`Filtered mod-tools output: ${line}`);
        sendStatusUpdate(line);
      });
    
      stdout += filteredOutput + "\n"; // Seguir almacenando en stdout
    
      if (
        command === "runoverlay" &&
        filteredOutput.includes("Status: Waiting for league match to start")
      ) {
        resolve({ success: true, pid: process.pid });
      }
    });
    
    process.stderr.on("data", (data) => {
      stderr += data.toString();
      console.error(`mod-tools error: ${data}`);
    });

    process.on("close", (code) => {
      if (command === "runoverlay") return;

      if (code === 0) {
        if (command === "import" || command === "mkoverlay") {
          resolve({ success: true });
        } else {
          reject(new Error(`Unexpected output: ${stdout.trim()}`));
        }
      } else {
        reject(new Error(stderr || `Process exited with code ${code}`));
      }
    });
  });
}

async function restartModTools() {
  try {
    await killModTools();

    // Construir el argumento --mods con todas las skins instaladas
    const installedFiles = Array.from(installedSkins.values())
      .map(skin => skin.fileName)
      .join(',');

    const args = [
      PROFILES_PATH,
      `--game:${GAME_PATH}`,
      'configless'
    ];

    if (installedFiles) {
      args.push(`--mods:${installedFiles}`);
    }

    const { success, pid } = await runModToolCommand('runoverlay', args);

    if (success && pid) {
      modToolsProcess = { pid };
      return true;
    }
    return false;
  } catch (error) {
    console.error('Error restarting mod-tools:', error);
    return false;
  }
}

async function cleanupTempFiles() {
  try {
    const files = await fs.readdir(INSTALLED_PATH);
    for (const file of files) {
      if (file.endsWith('.tmp')) {
        try {
          await fs.unlink(path.join(INSTALLED_PATH, file));
        } catch (error) {
          console.error('Failed to delete temp file:', file, error);
        }
      }
    }
  } catch (error) {
    console.error('Error during temp file cleanup:', error);
  }
}

// IPC Handlers
//Receive and store the name.
ipcMain.handle('install-skin', async (event, { championId, skinId, fileName, chromaName, imageUrl, baseSkinName }) => {
  try {
    const filePath = path.join(INSTALLED_PATH, fileName);
      
    // Ensure the file exists
    try {
      await fs.access(filePath);
    } catch (error) {
      throw new Error(`Skin file not found: ${fileName}`);
    }

    // Kill existing mod-tools process if any
    await killModTools();

    // Clean up any temporary files
    await cleanupTempFiles();

    // Create necessary directories
    await ensureDirectories();

    // Copy the skin file to the installed directory
    const installedFilePath = path.join(INSTALLED_PATH, fileName);
    await fs.copyFile(filePath, installedFilePath);

    // Import skin
    await runModToolCommand('import', [
      installedFilePath,
      installedFilePath,
      '--noTFT'
    ]);

    // Update installedSkins map with chroma and imageUrl information, including skinName.
    installedSkins.set(championId, {
      skinId,
      fileName,
      chromaName,
      imageUrl, // Store imageUrl
      skinName: baseSkinName, // Store baseSkinName
      processId: null
    });


    // Save to installed.json
    await saveInstalledSkins();

    // Create overlay with all installed skins
    const modsArg = Array.from(installedSkins.values())
      .map(skin => skin.fileName)
      .join('/');

    await runModToolCommand('mkoverlay', [
      INSTALLED_PATH,
      PROFILES_PATH,
      `--game:${GAME_PATH}`,
      `--mods:${modsArg}`
    ]);

    // Start mod-tools process
    const result = await restartModTools();
    return { success: true, ...result };
  } catch (error) {
    console.error('Error installing skin:', error);
    return { success: false, error: error.message };
  }
});

async function createOverlayOnly() {
  try {
    // Recreate overlay with all installed skins
    if (installedSkins.size > 0) {
      const modsArg = Array.from(installedSkins.values())
        .map(skin => skin.fileName)
        .join('/');

      await runModToolCommand('mkoverlay', [
        INSTALLED_PATH,
        PROFILES_PATH,
        `--game:${GAME_PATH}`,
        `--mods:${modsArg}`
      ]);
      
      return { success: true };
    } else {
      console.log('No skins to create overlay for');
      return { success: true };
    }
  } catch (error) {
    console.error('Failed to create overlay:', error);
    return { success: false, error: error.message };
  }
}

ipcMain.handle('uninstall-skin', async (event, championId) => {
  try {
    const skinInfo = installedSkins.get(championId);
    if (!skinInfo) {
      throw new Error('No skin installed for this champion');
    }

    // Detener mod-tools
    await killModTools();

    // Eliminar el archivo de la skin
    const filePath = path.join(INSTALLED_PATH, skinInfo.fileName);
    try {
      await fs.unlink(filePath);
    } catch (error) {
      console.error('Error removing skin file:', error);
      // Mover a archivo temporal si no se puede eliminar
      const tempPath = `${filePath}.tmp`;
      await fs.rename(filePath, tempPath);
    }

    // Eliminar la entrada del mapa y guardar
    installedSkins.delete(championId);
    await saveInstalledSkins();

    // Recrear overlay con las skins restantes, pero sin reiniciar mod-tools
    await createOverlayOnly();

    return { success: true };
  } catch (error) {
    console.error('Uninstall error:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('uninstall-multiple-skins', async (event, championIds) => {
  try {
    if (!Array.isArray(championIds) || championIds.length === 0) {
      throw new Error('No champions selected for uninstallation');
    }

    // Detener mod-tools
    await killModTools();

    // Process each skin removal
    for (const championId of championIds) {
      const skinInfo = installedSkins.get(championId);
      if (!skinInfo) continue; // Skip if not found

      // Eliminar el archivo de la skin
      const filePath = path.join(INSTALLED_PATH, skinInfo.fileName);
      try {
        await fs.unlink(filePath);
      } catch (error) {
        console.error(`Error removing skin file for champion ${championId}:`, error);
        // Mover a archivo temporal si no se puede eliminar
        const tempPath = `${filePath}.tmp`;
        await fs.rename(filePath, tempPath);
      }

      // Eliminar la entrada del mapa
      installedSkins.delete(championId);
    }

    // Guardar cambios
    await saveInstalledSkins();

    // Recrear overlay con las skins restantes, pero sin reiniciar mod-tools
    await createOverlayOnly();

    return { success: true };
  } catch (error) {
    console.error('Uninstall multiple skins error:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('start-overlay', async () => {
  try {
    const success = await restartModTools();
    if (!success) {
      throw new Error('Failed to start mod-tools process');
    }
    return { success: true };
  } catch (error) {
    console.error('Start overlay error:', error);
    return { success: false, error: error.message };
  }
});

// New handler for stopping the mod-tools overlay
ipcMain.handle('stop-overlay', async () => {
  try {
    const success = await killModTools();
    if (!success) {
      throw new Error('Failed to stop mod-tools process');
    }
    return { success: true };
  } catch (error) {
    console.error('Stop overlay error:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('save-mod-status', async (event, statusData) => {
  try {
    await ensureModStatusDirectory();
    await fs.writeFile(MOD_STATUS_PATH, JSON.stringify(statusData, null, 2));
    console.log('Saved mod status to:', MOD_STATUS_PATH);
    return { success: true };
  } catch (error) {
    console.error('Error saving mod status:', error);
    return { success: false, error: error.message };
  }
});

ipcMain.handle('get-mod-status', async () => {
  try {
    await ensureModStatusDirectory();
    try {
      const data = await fs.readFile(MOD_STATUS_PATH, 'utf8');
      console.log('Loaded mod status from:', MOD_STATUS_PATH);
      return JSON.parse(data);
    } catch (error) {
      // If file doesn't exist, return null
      if (error.code === 'ENOENT') {
        console.log('No mod status file found at:', MOD_STATUS_PATH);
        return null;
      }
      throw error;
    }
  } catch (error) {
    console.error('Error reading mod status:', error);
    return null;
  }
});

ipcMain.handle('get-installed-skins', async () => {
  return [...installedSkins];
});

ipcMain.handle('cleanup-localStorage', async () => {
  try {
    // Remove mod status JSON file
    await fs.unlink(MOD_STATUS_PATH).catch((err) => {
      console.log('No mod status file to delete or error:', err);
    });
    return { success: true };
  } catch (error) {
    console.error('Cleanup error:', error);
    return { success: false };
  }
});

// App event handlers
app.on('ready', async () => {
  await ensureDirectories();
  await loadInstalledSkins();
  await cleanupTempFiles();
  createWindow();
});

app.on('window-all-closed', function () {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', function () {
  if (mainWindow === null) {
    createWindow();
  }
});

// Cleanup on app quit
app.on('before-quit', async () => {
  await killModTools();
  if (mainWindow) {
    mainWindow.webContents.send('cleanup-storage');
  }
});
/// data End of electron.js ///

/// data Start of hooks.js ///
import React, { useEffect, useState } from "react";
import { useNavigate } from "react-router";
import { GetModStatus, SaveModStatus, StartRunOverlay, StopRunOverlay } from "../../wailsjs/go/main/App";
import { EventsOn, EventsOff } from "../../wailsjs/runtime/runtime";

export function usePromise(p) {
  const [data, setData] = useState(null);
  useEffect(() => {
    p.then((value) => setData(value));
  });
  return data;
}

export function navigate(to) {
  window.location.hash = to;
  return null;
}

export function useTitle(title) {
  useEffect(() => {
    const oldTitle = document.title;
    document.title = `${title} · Skin Hunter`;
    return () => void (document.title = oldTitle);
  }, [title]);
}

export function useEscapeTo(url) {
  const navigate = useNavigate();
  useEffect(() => {
    function onKeyDown(e) {
      if (e.code === "Escape") {
        navigate(url);
        e.preventDefault();
      }
    }

    document.addEventListener("keydown", onKeyDown);
    return () => document.removeEventListener("keydown", onKeyDown);
  }, [navigate, url]);
}

export function useLocalStorageState(name, initialValue) {
  const [value, _setValue] = useState(
    localStorage[name] ? JSON.parse(localStorage[name]) : initialValue
  );
  const setValue = (v) => {
    _setValue(v);
    localStorage[name] = JSON.stringify(v);
  };
  return [value, setValue];
}

export const useModStatus = () => {
  const [status, setStatus] = useState("idle");
  const [isDisabled, setIsDisabled] = useState(false);
  const [logs, setLogs] = useState([]);
  const [waitingForExit, setWaitingForExit] = useState(false);
  const [currentStatusMessage, setCurrentStatusMessage] = useState("Waiting...");

  // Reset status on component mount
  useEffect(() => {
    // Reset mod status on startup
    SaveModStatus({ status: "idle", isDisabled: false })
      .then(() => {
        setStatus("idle");
        setIsDisabled(false);
        setWaitingForExit(false);
        
        // Update global status
        if (window.updateGlobalStatus) {
          window.updateGlobalStatus("Ready to start");
        }
      })
      .catch(console.error);
      
    // Check if mod-tools is actually running
    GetModStatus()
      .then(savedStatus => {
        if (savedStatus && savedStatus.status === "running") {
          // Verify if process is actually running
          CheckModToolsRunning()
            .then(isRunning => {
              if (!isRunning) {
                // Process not running but status says it is - reset
                SaveModStatus({ status: "idle", isDisabled: false });
                setStatus("idle");
              }
            })
            .catch(console.error);
        }
      })
      .catch(console.error);
  }, []);

  useEffect(() => {
    const handleOverlayStarted = (data) => {
      console.log("Overlay started event received:", data);
      setStatus("running");
      setIsDisabled(false);
      setWaitingForExit(false);
      setCurrentStatusMessage("Waiting for league match to start");
      SaveModStatus({ status: "running", isDisabled: false });
      
      // Update global status for AppInterface
      if (window.updateGlobalStatus) {
        window.updateGlobalStatus("Waiting for league match to start");
      }
    };

    const handleOverlayStopped = (data) => {
      console.log("Overlay stopped event received:", data);
      setStatus(data.exitError ? "error" : "stopped");
      setIsDisabled(false);
      setWaitingForExit(false);
      setCurrentStatusMessage(data.exitError ? "Error occurred" : "Stopped");
      SaveModStatus({ 
        status: data.exitError ? "error" : "stopped", 
        isDisabled: false 
      });
      
      // Update global status for AppInterface
      if (window.updateGlobalStatus) {
        window.updateGlobalStatus(data.exitError ? "Error occurred" : "Stopped");
      }
    };

    const handleStdoutUpdate = (data) => {
      setLogs((prev) => [
        ...prev,
        {
          type: "stdout",
          message: data.content,
          timestamp: data.time,
          id: Date.now(),
        },
      ]);
      
      // Check for waiting for exit message
      if (data.content.includes("Waiting for exit")) {
        setWaitingForExit(true);
        setCurrentStatusMessage("Waiting for exit");
        
        // Update global status for AppInterface
        if (window.updateGlobalStatus) {
          window.updateGlobalStatus("Waiting for exit");
        }
      }
      
      // Check for waiting for league match message
      if (data.content.includes("Waiting for league match to start")) {
        setWaitingForExit(false);
        setCurrentStatusMessage("Waiting for league match to start");
        
        // Update global status for AppInterface
        if (window.updateGlobalStatus) {
          window.updateGlobalStatus("Waiting for league match to start");
        }
      }
      
      // Update global status for AppInterface with any message
      if (window.updateGlobalStatus) {
        window.updateGlobalStatus(data.content);
      }
    };

    const handleStderrUpdate = (data) => {
      setLogs((prev) => [
        ...prev,
        {
          type: "stderr",
          message: data.content,
          timestamp: data.time,
          id: Date.now(),
        },
      ]);
      if (data.content.toLowerCase().includes("error")) {
        setStatus("error");
        SaveModStatus({ status: "error", isDisabled: false }).catch(console.error);
      }
    };

    // Register all event listeners
    EventsOn("overlay-started", handleOverlayStarted);
    EventsOn("overlay-stopped", handleOverlayStopped);
    EventsOn("overlay-stdout-update", handleStdoutUpdate);
    EventsOn("overlay-stderr-update", handleStderrUpdate);

    // Cleanup function
    return () => {
      EventsOff("overlay-started");
      EventsOff("overlay-stopped");
      EventsOff("overlay-stdout-update");
      EventsOff("overlay-stderr-update");
    };
  }, []); // Remove status dependency to avoid redeclaration issues

    const toggleOverlay = async () => {
      setIsDisabled(true);
      const currentState = status; // Capture state at start of operation
      try {
        // If stopped, idle, or error -> try starting
        if (currentState === "stopped" || currentState === "idle" || currentState === "error") {
          console.log("Attempting to start overlay...");
          const result = await StartRunOverlay(); // StartOverlay now handles cleanup if necessary
          if (!result.success && result.message !== "Overlay is already running") { // Allow "already running" as success
            throw new Error(result.error || "Failed to start overlay");
          }
           // Event 'overlay-started' should update the status to 'running'
        }
        // If running -> try stopping
        else if (currentState === "running") {
          console.log("Attempting to stop overlay...");
          const result = await StopRunOverlay();
          if (!result.success) {
            throw new Error(result.error || "Failed to stop overlay");
          }
           // Event 'overlay-stopped' should update the status
        }
        // Add handling for 'exiting' state if needed, perhaps do nothing or wait.
        else if (currentState === 'exiting') {
            console.log("Overlay is already stopping, please wait.");
            // Optionally re-enable button after a delay or rely on events
        }

      } catch (error) {
        console.error("Error toggling overlay:", error);
        // Set status to error on failure, event listener might override this shortly if stop succeeds anyway
        setStatus("error");
        SaveModStatus({ status: "error", isDisabled: false }).catch(console.error);
        // No need to manually re-enable button here because of finally block
        toast.error(error.message || "Failed to toggle overlay"); // Show toast on error
        // Re-throw the error if needed by calling component, but toast is usually sufficient
        // throw error;
      } finally {
        // Re-enable button *unless* an operation successfully initiated start/stop
        // Rely on events 'overlay-started' and 'overlay-stopped' to set isDisabled = false
        // Let's keep it simple: always re-enable here, events will update state shortly after.
         setIsDisabled(false);
         // SaveModStatus({ status: status, isDisabled: false }).catch(console.error); // Maybe save status here too? Or rely on event handlers. Relying on events is cleaner.
      }
    };

    const clearLogs = () => setLogs([]);

    // Expose setStatus for external components
    const updateStatus = (newStatus) => {
      setStatus(newStatus);
      SaveModStatus({ status: newStatus, isDisabled: false })
        .catch(console.error);
    };

    return { 
    status, 
    isDisabled, 
    toggleOverlay, 
    logs, 
    clearLogs, 
    waitingForExit,
    currentStatusMessage,
    setStatus: updateStatus
  };
};

export default useModStatus;
/// data End of hooks.js ///

/// pages Start of appinterface.jsx ///
import React, { useState, useEffect } from 'react';
import { ArrowLeft, Search, Settings, Grid, Download, User, Layers } from "lucide-react";
import { ChampionsIndex, Champion } from './champions';
import { Omnisearch } from '../components/Omnisearch';
import { useParams } from 'react-router-dom';
import InstalledSkinsDialog from '../components/InstalledSkin';
import ContainerForm from '../components/ContainerForm';
import { Code, Container, Flex, Heading, Text, Section, Dialog, ScrollArea } from '@radix-ui/themes';
import { ProfileDialog } from '../components/ProfileDialog';
import { useUser } from '../context/usercontext';
import { SkinLine, SkinLinesIndex } from '../components/SkinLines';
import { motion, AnimatePresence } from 'framer-motion';
import ModOverlayButton from '../components/ModOverlayButton';
import { GetUserData, GetModStatus } from '../../wailsjs/go/main/App';
import { EventsOn, EventsOff } from "../../wailsjs/runtime/runtime";
// Import virtualization and lazy loading components
import { FixedSizeGrid } from 'react-window';
import AutoSizer from 'react-virtualized-auto-sizer';
import { LazyLoadImage } from 'react-lazy-load-image-component';
import 'react-lazy-load-image-component/src/effects/blur.css';

const TabTransition = ({ children, className }) => (
  <motion.div
    initial={{ opacity: 0, y: 20 }}
    animate={{ opacity: 1, y: 0 }}
    exit={{ opacity: 0, y: -20 }}
    transition={{ duration: 0.3, ease: "easeInOut" }}
    className={className}
  >
    {children}
  </motion.div>
);

const IconToggle = ({ showingSkinLines }) => (
  <motion.img
    initial={{ scale: 0.8, opacity: 0 }}
    animate={{ scale: 1, opacity: 1 }}
    exit={{ scale: 0.8, opacity: 0 }}
    transition={{ duration: 0.2 }}
    src={showingSkinLines
      ? "https://raw.communitydragon.org/latest/plugins/rcp-fe-lol-static-assets/global/default/images/skin-viewer/icon-three-masks-default.svg"
      : "https://raw.communitydragon.org/latest/plugins/rcp-fe-lol-static-assets/global/default/images/reward-tracker/item-category-icons/champion.png"
    }
    alt={showingSkinLines ? "Skin Lines" : "Champions"}
    className="w-6 h-6 filter brightness-75 hover:brightness-100 transition-all grayscale"
  />
);

// Modify the ChampionsIndex component to use virtualization
// Add this import at the top of the file
import { EnhancedImage } from './champions';

// Then in the VirtualizedChampionsIndex component, replace LazyLoadImage with EnhancedImage
const VirtualizedChampionsIndex = ({ onChampionSelect }) => {
  const [champions, setChampions] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  
  useEffect(() => {
    // Your existing champion loading logic
    fetch('https://ddragon.leagueoflegends.com/cdn/14.9.1/data/en_US/champion.json')
      .then(response => response.json())
      .then(data => {
        const champList = Object.values(data.data);
        setChampions(champList);
      })
      .catch(error => console.error('Error fetching champions:', error));
  }, []);

  const filteredChampions = champions.filter(champion => 
    champion.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // Calculate grid dimensions
  const ITEM_WIDTH = 120;
  const ITEM_HEIGHT = 150;
  const ITEMS_PER_ROW = 5; // Adjust based on your layout

  // Render a champion cell
  const ChampionCell = ({ champion, style }) => (
    <motion.div
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
      onClick={() => onChampionSelect(champion.id)}
      className="flex flex-col items-center p-2 cursor-pointer"
      style={style}
    >
      <div className="w-16 h-16 rounded-full overflow-hidden mb-2">
        <LazyLoadImage
          src={`https://ddragon.leagueoflegends.com/cdn/14.9.1/img/champion/${champion.image.full}`}
          alt={champion.name}
          effect="blur"
          width={64}
          height={64}
          className="w-full h-full object-cover"
          threshold={100}
          placeholderSrc="https://via.placeholder.com/64?text=..."
        />
      </div>
      <Text size="1" className="text-center text-gray-200">{champion.name}</Text>
    </motion.div>
  );

  // Cell renderer for react-window
  const Cell = ({ columnIndex, rowIndex, style }) => {
    const index = rowIndex * ITEMS_PER_ROW + columnIndex;
    if (index >= filteredChampions.length) return null;
    
    const champion = filteredChampions[index];
    return (
      <motion.div
        whileHover={{ scale: 1.05 }}
        whileTap={{ scale: 0.95 }}
        onClick={() => onChampionSelect(champion.id)}
        className="flex flex-col items-center p-2 cursor-pointer"
        style={style}
      >
        <div className="w-16 h-16 rounded-full overflow-hidden mb-2">
          <EnhancedImage
            src={`https://ddragon.leagueoflegends.com/cdn/14.9.1/img/champion/${champion.image.full}`}
            alt={champion.name}
            className="w-full h-full object-cover"
            style={{ backgroundColor: '#1e293b' }}
            onError={(e) => {
              console.error("Failed to load champion image:", champion.name);
            }}
          />
        </div>
        <Text size="1" className="text-center text-gray-200">{champion.name}</Text>
      </motion.div>
    );
  };

  return (
    <div className="w-full h-full">
      <div className="mb-4 px-4">
        <input
          type="text"
          placeholder="Search champions..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full p-2 bg-gray-800 text-white rounded"
        />
      </div>
      
      <div className="w-full h-[calc(100%-60px)]">
        <AutoSizer>
          {({ height, width }) => {
            const columnCount = Math.floor(width / ITEM_WIDTH) || ITEMS_PER_ROW;
            const rowCount = Math.ceil(filteredChampions.length / columnCount);
            
            return (
              <FixedSizeGrid
                columnCount={columnCount}
                columnWidth={ITEM_WIDTH}
                height={height}
                rowCount={rowCount}
                rowHeight={ITEM_HEIGHT}
                width={width}
              >
                {Cell}
              </FixedSizeGrid>
            );
          }}
        </AutoSizer>
      </div>
    </div>
  );
};

// Similarly, update the SkinLinesIndex component
const VirtualizedSkinLinesIndex = ({ onSkinLineSelect }) => {
  const [skinLines, setSkinLines] = useState([]);
  const [searchTerm, setSearchTerm] = useState('');
  
  useEffect(() => {
    // Your existing skin lines loading logic
    fetch('https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/v1/skinlines.json')
      .then(response => response.json())
      .then(data => {
        const filteredLines = data.filter(line => line.id > 0);
        setSkinLines(filteredLines);
      })
      .catch(error => console.error('Error fetching skin lines:', error));
  }, []);

  const filteredSkinLines = skinLines.filter(line => 
    line.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // Calculate grid dimensions
  const ITEM_WIDTH = 160;
  const ITEM_HEIGHT = 200;
  const ITEMS_PER_ROW = 4; // Adjust based on your layout

  // Render a skin line cell
  const SkinLineCell = ({ skinLine, style }) => (
    <motion.div
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.95 }}
      onClick={() => onSkinLineSelect(skinLine.id)}
      className="flex flex-col items-center p-2 cursor-pointer"
      style={style}
    >
      <div className="w-24 h-24 rounded-lg overflow-hidden mb-2">
        <LazyLoadImage
          src={`https://raw.communitydragon.org/latest/plugins/rcp-be-lol-game-data/global/default/assets/skinlines/${skinLine.id.toString().padStart(4, '0')}-${skinLine.name.toLowerCase().replace(/\s+/g, '')}/splash.jpg`}
          alt={skinLine.name}
          effect="blur"
          width={96}
          height={96}
          className="w-full h-full object-cover"
          threshold={100}
          placeholderSrc="https://via.placeholder.com/96?text=..."
          onError={(e) => {
            e.target.onerror = null;
            e.target.src = "https://via.placeholder.com/96?text=No+Image";
          }}
        />
      </div>
      <Text size="1" className="text-center text-gray-200">{skinLine.name}</Text>
    </motion.div>
  );

  // Cell renderer for react-window
  const Cell = ({ columnIndex, rowIndex, style }) => {
    const index = rowIndex * ITEMS_PER_ROW + columnIndex;
    if (index >= filteredSkinLines.length) return null;
    
    const skinLine = filteredSkinLines[index];
    return <SkinLineCell skinLine={skinLine} style={style} />;
  };

  return (
    <div className="w-full h-full">
      <div className="mb-4 px-4">
        <input
          type="text"
          placeholder="Search skin lines..."
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          className="w-full p-2 bg-gray-800 text-white rounded"
        />
      </div>
      
      <div className="w-full h-[calc(100%-60px)]">
        <AutoSizer>
          {({ height, width }) => {
            const columnCount = Math.floor(width / ITEM_WIDTH) || ITEMS_PER_ROW;
            const rowCount = Math.ceil(filteredSkinLines.length / columnCount);
            
            return (
              <FixedSizeGrid
                columnCount={columnCount}
                columnWidth={ITEM_WIDTH}
                height={height}
                rowCount={rowCount}
                rowHeight={ITEM_HEIGHT}
                width={width}
              >
                {Cell}
              </FixedSizeGrid>
            );
          }}
        </AutoSizer>
      </div>
    </div>
  );
};

// Update the MainContent component to use the virtualized components
const MainContent = ({ activeTab, selectedChampion, setSelectedChampion, selectedSkinLine, setSelectedSkinLine }) => {
  const { champion } = useParams();
  const { userData, setUserData } = useUser();
  const { revalidateUser } = useUser();

  const [isLoading, setIsLoading] = useState(true);
  const handleChampionSelect = (championKey) => {
    setSelectedChampion(championKey);
  };
  const handleSkinLineSelect = (skinLineId) => {
    setSelectedSkinLine(skinLineId);
  };
  useEffect(() => {
    const fetchUserData = async () => {
      const token = localStorage.getItem("token");

      if (!token) {
        setIsLoading(false);
        return;
      }

      try {
        const response = await GetUserData(token);
        if (response.success) {
          setUserData(response.user);
        } else {
          throw new Error(response.error || 'Failed to load user data');
        }
      } catch (error) {
        console.error("Error fetching user data:", error);
        if (error.message.includes('token')) {
          localStorage.removeItem("token");
          setUserData(null);
        }
      } finally {
        setIsLoading(false);
      }
    };

    fetchUserData();
  }, [setUserData]);

  const handleLogout = () => {
    localStorage.removeItem("token");
    setUserData(null);
  };
  switch (activeTab) {

    case 'champions':
      if (selectedSkinLine) {
        return (
          <SkinLine skinLineId={selectedSkinLine} onBack={() => setSelectedSkinLine(null)} />
        );
      }
      return selectedChampion ? (
        <Champion champion={selectedChampion} onBack={() => setSelectedChampion(null)} />
      ) : (
        <ChampionsIndex onChampionSelect={handleChampionSelect} />
      );

    case 'installed':
      return (
        <Section className="bg-transparent">
          <Heading as="h1" size="5" align="center">Installed Skins</Heading>
          <ScrollArea
            className="mt-4"
            type="auto"
            scrollbars="vertical"
          >
            <InstalledSkinsDialog />
          </ScrollArea>
        </Section>
      );
    case 'profile':
      return (
        <Section className="pt-24 bg-transparent">
          <Container size="4" p="4" className="bg-transparent">
            <ProfileDialog userData={userData} onLogout={handleLogout} />
          </Container>
        </Section>
      );
    default:
      return <ChampionsIndex />;
  }
};

const AppInterface = () => {
  const [activeTab, setActiveTab] = useState('champions');
  const [isOmnisearchOpen, setIsOmnisearchOpen] = useState(false);
  const [currentStatus, setCurrentStatus] = useState('Waiting...');
  const isAuthenticated = !!localStorage.getItem("token");
  const [loginOpen, setLoginOpen] = useState(false);
  const [profileOpen, setProfileOpen] = useState(false);
  const [currentPopup, setCurrentPopup] = useState("login");
  const [selectedChampion, setSelectedChampion] = useState(null);
  const [selectedSkinLine, setSelectedSkinLine] = useState(null);
  const [showingSkinLines, setShowingSkinLines] = useState(false);
  const handleSkinLinesClick = () => {
    setShowingSkinLines(!showingSkinLines);
    setSelectedChampion(null);
    setSelectedSkinLine(null);
  };

  useEffect(() => {
    // Cargar el estado desde localStorage al iniciar
    const savedStatus = localStorage.getItem('modStatus');
    if (savedStatus) {
      setCurrentStatus(savedStatus);
    }

    // Create a global function to update status from anywhere
    window.updateGlobalStatus = (newStatus) => {
      console.log('New status received:', newStatus);
      
      // Clean up the status message if needed
      const formattedStatus = newStatus.replace("Status: ", "");
      
      setCurrentStatus(formattedStatus);
      
      // Save to localStorage for persistence
      localStorage.setItem('modStatus', formattedStatus);
    };

    // Listen for events from the backend
    EventsOn("overlay-stdout-update", (data) => {
      window.updateGlobalStatus(data.content);
    });
    
    EventsOn("overlay-stderr-update", (data) => {
      window.updateGlobalStatus(`Error: ${data.content}`);
    });

    return () => {
      // Clean up event listeners
      delete window.updateGlobalStatus;
      EventsOff("overlay-stdout-update");
      EventsOff("overlay-stderr-update");
    };
  }, []);

  return (
    <div className="flex flex-col h-screen text-gray-200">
      {/* Header */}
      <header className="bg-[#0f1729] w-full border-b-2 border-[#586a9e] fixed inline-flex items-center px-[13px] z-[71]" style={{ WebkitAppRegion: "drag", paddingTop: "1.1rem", paddingBottom: "1.1rem" }}>
        <img className="ml-[7px] w-52 aspect-[900/167]" src="https://i.imgur.com/m40l0qA.png" alt="cancer" />
        <Flex direction="row" className='absolute left-1/2 transform -translate-x-1/2' style={{ padding: "inherit" }}><Code variant='outline'>{currentStatus}</Code></Flex>
      </header>

      {/* Main content area with background image and transparent asides */}
      <section className={`flex flex-1 overflow-hidden z-50 ${activeTab === 'installed' ? 'pb-0' : 'pb-[154px]'}`}>
        {/* Background image layer that spans the entire width */}
        <div 
          className="absolute top-[73px] left-0 right-0 bottom-0 z-10" 
          style={{ 
            backgroundImage: "url('https://skinhunter.s-ul.eu/NJCK7P1q')",
          }}
        ></div>
        
        {/* Left Aside - now with transparent background */}
        <aside className="w-20 flex flex-col items-center py-4 h-dvh z-[60] backdrop-blur-sm relative">
          {activeTab === 'champions' && (selectedChampion || selectedSkinLine) ? (
            <motion.button
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.95 }}
              onClick={() => {
                setSelectedChampion(null);
                setSelectedSkinLine(null);
              }}
              className="text-gray-400 hover:text-gray-200 mt-20 z-[61]"
            >
              <ArrowLeft size={24} />
            </motion.button>
          ) : activeTab === 'champions' && !selectedChampion && !selectedSkinLine && (
            <motion.button
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.95 }}
              onClick={handleSkinLinesClick}
              className={`text-gray-400 hover:text-gray-200 mt-20 z-[61] ${showingSkinLines ? 'text-gray-200' : ''}`}
            >
              <AnimatePresence mode="wait">
                <IconToggle showingSkinLines={showingSkinLines} />
              </AnimatePresence>
            </motion.button>
          )}
        </aside>

        {/* Main Content */}
        <ScrollArea 
          type='scroll' 
          scrollbars="vertical" 
          className="flex-1 bg-transparent h-full mt-[73px] px-4 relative z-20" 
          style={{ height: "maxHeight", transform: "scaleY(1.03)" }}
        >
          <AnimatePresence mode="wait">
            {activeTab === 'installed' ? (
              <TabTransition key="installed">
                <div className="p-4">
                  <InstalledSkinsDialog />
                </div>
              </TabTransition>
            ) : activeTab === 'champions' && showingSkinLines && !selectedChampion && !selectedSkinLine ? (
              <TabTransition key="skinlines">
                <SkinLinesIndex onSkinLineSelect={(id) => setSelectedSkinLine(id)} />
              </TabTransition>
            ) : activeTab === 'champions' ? (
              <TabTransition key="champions">
                <MainContent
                  activeTab={activeTab}
                  selectedChampion={selectedChampion}
                  setSelectedChampion={setSelectedChampion}
                  selectedSkinLine={selectedSkinLine}
                  setSelectedSkinLine={setSelectedSkinLine}
                />
              </TabTransition>
            ) : activeTab === 'profile' && isAuthenticated ? (
              <TabTransition key="profile">
                <div className="p-4">
                  <ProfileDialog />
                </div>
              </TabTransition>
            ) : null}
          </AnimatePresence>
        </ScrollArea>

        {/* Right Aside - now with transparent background */}
        <aside className="w-20 flex flex-col items-center py-4 h-dvh z-[60]  backdrop-blur-sm relative">
          <ModOverlayButton></ModOverlayButton>
        </aside>
      </section>

      {/* Omnisearch Dialog */}
      <Omnisearch 
        isOpen={isOmnisearchOpen} 
        onOpenChange={setIsOmnisearchOpen}
        setActiveTab={setActiveTab}
        setSelectedChampion={setSelectedChampion}
        setSelectedSkinLine={setSelectedSkinLine}
      />

      {/* Bottom navigation */}
      <nav className="flex justify-center gap-16 py-4 bg-[#0f1729] border-t-2 border-[#586a9e] z-50 fixed w-full bottom-0 ">
        <button
          className={`flex flex-col items-center gap-1 transition-colors group ${activeTab === 'champions' ? 'text-gray-200' : 'text-gray-400 hover:text-gray-200'
            }`}
          onClick={() => setActiveTab('champions')}
        >
          <Grid className="w-5 h-5" />
          <span className="text-xs font-medium">Champions</span>
        </button>

        <button
          className={`flex flex-col items-center gap-1 transition-colors group ${activeTab === 'search' ? 'text-gray-200' : 'text-gray-400 hover:text-gray-200'
            }`}
          onClick={() => setIsOmnisearchOpen(true)}
        >
          <Search className="w-5 h-5" />
          <span className="text-xs font-medium">Search</span>
        </button>

        <button
          className={`flex flex-col items-center gap-1 transition-colors group ${activeTab === 'installed' ? 'text-gray-200' : 'text-gray-400 hover:text-gray-200'
            }`}
          onClick={() => setActiveTab('installed')}
        >
          <Download className="w-5 h-5" />
          <span className="text-xs font-medium">Installed</span>
        </button>

        {isAuthenticated && (
          <button
            className={`flex flex-col items-center gap-1 transition-colors group ${activeTab === 'settings' ? 'text-gray-200' : 'text-gray-400 hover:text-gray-200'
              }`}
            onClick={() => setActiveTab('profile')}
          >
            <User className="w-5 h-5" />
            <span className="text-xs font-medium">Profile</span>
          </button>
        )}

        {!isAuthenticated && (
          <Dialog.Root open={loginOpen} onOpenChange={setLoginOpen}>
            <Dialog.Trigger>
              <button
                className={`flex flex-col items-center gap-1 transition-colors group ${activeTab === 'settings' ? 'text-gray-200' : 'text-gray-400 hover:text-gray-200'
                  }`}
                onClick={() => open = { loginOpen }}
              >
                <User className="w-5 h-5" />
                <span className="text-xs font-medium">Profile</span>
              </button>
            </Dialog.Trigger>
            <Dialog.Content aria-describedby={undefined}>
              <ContainerForm
                closePopup={() => setLoginOpen(false)}
                setCurrentPopup={setCurrentPopup}
                currentPopup={currentPopup}
              />
            </Dialog.Content>
          </Dialog.Root>
        )}
      </nav>
    </div>
  );
};

export default AppInterface;
/// pages End of appinterface.jsx ///

/// pages Start of champions.jsx ///
import React, { useEffect, useState, memo } from 'react';
import { Grid, Text, Card, Box, Flex, Heading, Skeleton, Container, Separator, Blockquote, Section, Dialog } from '@radix-ui/themes';
import { asset, champions, _ready, championSkins, rarity, _champData, style, checkLegacy, _champChromas, getChromasForSkin, _champDataName } from '../data/data';
import { navigate, useEscapeTo, useTitle } from '../data/hooks';
import { Link, generatePath, useParams, useNavigate } from "react-router-dom";
import ChampionDialog from '../components/ChampionDialog';
import { SkinsGrid } from '../components/SkinsGrid';
import { ArrowLeft} from 'lucide-react';



export const EnhancedImage = memo(({ src, alt, className, style, onLoad, onError }) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);
  const imgRef = useRef(null);
  
  useEffect(() => {
    // Reset states when src changes
    setIsLoaded(false);
    setHasError(false);
    
    // Preload image
    const img = new Image();
    img.src = src;
    img.onload = () => {
      setIsLoaded(true);
      if (onLoad) onLoad();
    };
    img.onerror = () => {
      setHasError(true);
      if (onError) onError();
    };
    
    return () => {
      img.onload = null;
      img.onerror = null;
    };
  }, [src]);
  
  return (
    <>
      {!isLoaded && !hasError && (
        <Skeleton className={className} style={style} />
      )}
      <img
        ref={imgRef}
        src={src}
        alt={alt}
        className={className}
        style={{
          ...style,
          display: isLoaded ? 'block' : 'none'
        }}
        onLoad={() => {
          setIsLoaded(true);
          if (onLoad) onLoad();
        }}
        onError={() => {
          setHasError(true);
          if (onError) onError();
        }}
      />
      {hasError && (
        <div 
          className={className} 
          style={{
            ...style,
            backgroundColor: '#1e293b',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center'
          }}
        >
          <Text size="1" color="gray">Error</Text>
        </div>
      )}
    </>
  );
});


export function ChampionsIndex({ onChampionSelect }) {
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingIndex, setIsLoadingIndex] = useState(true);

  const handleImageLoad = () => {
    setIsLoadingIndex(false);
  };
  useEffect(() => {
    _ready.then(() => setIsLoading(false));
  }, []);

  if (isLoading) {

    return (
      <Grid
        className="grid grid-cols-[repeat(auto-fit,80px)] gap-3 justify-center py-[15px]"
        gap="3"
        width="100%"
      >
        {Array.from({ length: 100 }).map((_, index) => (
          <Card variant="ghost" key={index} className='w-[120px]'>
            <Skeleton>
              <div className="w-[80px] h-[80px] bg-primary bg-contain align-middle justify-center "></div>
            </Skeleton>
            <Skeleton align="center">
              <div className="text-center mt-1 w-[60px] h-[10px] text-ellipsis overflow-hidden justify-center align-middle items-center">aaaaaaa</div>
            </Skeleton>

          </Card>
        ))}
      </Grid>
    );
  }

  return (
    <div className='mt-[15px]' >
      {/* <img src='https://skinhunter.s-ul.eu/NJCK7P1q' className='fixed object-cover '></img> */}
      <Grid className="grid grid-cols-[repeat(auto-fit,80px)] gap-3 justify-center" gap="3" width="100%" height="100%">
        {champions.map((c) => (
          <Card variant="ghost" key={c.id}>
            <div
              className="decoration-inherit text-ellipsis overflow-hidden text-nowrap cursor-pointer w-[80px] h-[110px] "
              title={c.name}
              onClick={() => onChampionSelect(c.key)}
            >
              <Box style={{ display: isLoadingIndex ? "none" : "block", width: "80px", height: "80px" }} className='bg-primary'>
                <img
                  src={`${asset(c.squarePortraitPath)}?w=80&h=80&format=webp`}
                  alt={c.name}
                  className="w-[80px] h-[80px] object-contain align-middle justify-center" 
                  style={{aspectRatio: "1 / 1"}}
                  onError={(e) => {
                    e.target.src = "/default-placeholder.png";
                  }}
                  onLoad={handleImageLoad}
                />
              </Box>
              <div className="text-center mt-1 text-ellipsis overflow-hidden text-nowrap">
                <Text size="2" weight="bold">{c.name}</Text>
              </div>
            </div>
          </Card>
        ))}
      </Grid>
    </div>
  );
}


export const SkinItem = memo(({ skin, champKey, asset, rarity }) => {
  const [isLoading, setIsLoading] = useState(true);

  const chromas = getChromasForSkin(skin);

  const handleImageLoad = () => {
    setIsLoading(false);
  };

  return (
    <Box
      style={{ willChange: "transform" }}
      className="relative rounded-lg overflow-hidden hover:scale-105 transition-transform"
      key={skin.id}
    >
        <Flex
          align="center"
          direction="column"
          justify="center"
          className="items-center"
        >
          {isLoading && (
            <Skeleton>
              <Box style={{ width: "200px", height: "200px" }} />
            </Skeleton>
          )}

          <Box
            style={{
              display: isLoading ? "none" : "block",
              width: "200px",
              height: "200px",
            }}
            className="bg-primary relative"
          >
            {checkLegacy(skin) && (
              <div className="absolute top-2 left-2 z-10">
                <img
                  width="24"
                  height="24"
                  src={checkLegacy(skin)[0]}
                  title={checkLegacy(skin)[1]}
                  alt="Legacy Icon"
                  style={{ filter: "brightness(0.8)" }}
                />
              </div>
            )}

            {chromas && (
              <div className="absolute top-2 right-2 z-10">
                <img
                  width="24"
                  height="24"
                  src="https://raw.communitydragon.org/latest/plugins/rcp-fe-lol-static-assets/global/default/images/skin-viewer/icon-chroma-default.png"
                  title="This skin has Chromas"
                  alt="Chromas Icon"
                  style={{
                    filter: "brightness(0.8)",
                    borderRadius: "50%",
                    cursor: "pointer",
                  }}
                />
              </div>
            )}

            <img
              src={asset(skin.tilePath)}
              alt={skin.name}
              style={{
                cursor: "url('https://cur.cursors-4u.net/games/gam-14/gam1339.cur')",
                objectFit: "cover",
                width: "100%",
                height: "100%"
              }}
              onLoad={handleImageLoad}
            />
          </Box>

          <Flex 
            direction="row" 
            align="center" 
            className="w-[200px] px-2 py-1 bg-black/50 backdrop-blur-sm"
          >
            {rarity(skin) && (
              <img
                className="mr-2"
                width="16"
                height="16"
                src={rarity(skin)[0]}
                title={rarity(skin)[1]}
                alt={rarity(skin)[1]}
              />
            )}
            <span className="text-sm text-white truncate">
              {skin.name}
            </span>
          </Flex>
        </Flex>
    </Box>
  );
});

export function Champion({ champion, onBack }) {
  const champ = champions.find((c) => c.key === champion);
  const [champData, setChampData] = useState(null);
  const [champChromas, setChampChromas] = useState([]);
  const styles = {

    kASGrey: ["continuum_icon_attackspeed_grey.png", "Attack"],
    kASHighlight: ["continuum_icon_attackspeed.png", "Attack"],
    kAPGrey: ["continuum_icon_abilitypower_grey.png", "Magic"],
    kMagicHighlight: ["continuum_icon_abilitypower.png", "Magic"],

  }

  const roleColors = {
    fighter: "red",
    tank: "blue",
    mage: "purple",
    assassin: "orange",
    marksman: "yellow",
    support: "green",
  };

  const damageColors = {
    kPhysical: "red",
    kMixed: "yellow",
    kMagic: "purple",
  };
  useTitle(champ?.name);
  useEscapeTo("/");

  if (!champ) return navigate("/");

  const skins = championSkins(champ.id);

  useEffect(() => {
    let isMounted = true;
    _champData(champ.id).then((data) => {
      if (isMounted && data) {
        const defaultSkins = data.skins.filter((skin) => skin.isBase);
        setChampData({
          ...data,
          defaultSkins,
        });
      }
    });
    return () => {
      setChampData(null); // Limpia datos al desmontar
    };
  }, [champ.id]);

  useEffect(() => {
    let isMounted = true;
    if (!champ.id) return;
    _champDataName(champ.id).then((champData) => {
      if (!isMounted || !champData || !champData.skins) return;
      const allChromas = champData.skins
        .map(getChromasForSkin)
        .filter(Boolean)
        .flat();
      setChampChromas(allChromas);
    });
    return () => {
      setChampChromas([]); // Limpia chromas al desmontar
    };
  }, [champ.id]);

  const capitalize = (str) => {
    if (!str) return '';
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  // debugLegacySkins(skins)
  // console.log(champChromas)
  return (

      <div className='h-max  relative'>


        <Box className='w-full'>

          <Container size="2" m="8">

            {champData ? (
              <>


                <Flex direction="row" align="start" gap="4">
                  { }



                  <Box >
                    { }
                    <Flex direction="row" align="center" gap="4">
                      { }
                      <img
                        src={`${asset(champData.squarePortraitPath)}?w=80&h=80&format=webp`}
                        alt={champData.name}
                        className="w-[80px] h-[80px] object-contain"
                        style={{ aspectRatio: "1 / 1" }}
                      />

                      { }
                      <Flex direction="column" justify="center">
                        { }
                        <Heading as="h2" size="lg" mb="1" textAlign="left">
                          {champData.name}
                        </Heading>

                        { }
                        <Text as="h3" fontSize="md" color="gray.600" textAlign="left">
                          {capitalize(champData.title)}
                          <Separator my="3" size="4" />


                        </Text>
                      </Flex>
                    </Flex>
                    { }
                    <div>
                      <Blockquote fontSize="sm" textAlign="left" color="#1e1e1e" mt="3" >
                        {champData.shortBio}
                      </Blockquote>
                    </div>
                    <ChampionDialog champData={champData} roleColors={roleColors} damageColors={damageColors} style={style} asset={asset}  ></ChampionDialog>

                  </Box>

                </Flex>
              </>




            ) : (
              <Skeleton><Container size="2"><Box className='w-[full] h-[200px] bg-primary'></Box></Container></Skeleton>
            )}




          </Container>
          <Flex display="inline-flex" direction="row" justify="center" align="center" className='items-center w-full relative mb-5'>
            <img style={{ marginRight: "10px" }}
              width="35" height="auto"
              src="https://raw.communitydragon.org/latest/plugins/rcp-fe-lol-static-assets/global/default/images/skins_rewards.svg"
              className="iconimg"
            />
            <Heading as='h2' size="6" align="center" className='relative'>

              {champ.name} Skins
            </Heading>
          </Flex>

          <SkinsGrid skins={skins} asset={asset} rarity={rarity} chromas={champChromas ?? []}></SkinsGrid>
        </Box>

      </div>
    // </Section>
  );
}


/// pages End of champions.jsx ///

